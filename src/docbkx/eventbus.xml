<?xml version="1.0" encoding="UTF-8"?>
<chapter annotations="" version="5.0" xml:id="the_eventbus"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>The EventBus</title>

  <section xml:id="the_eventbus_introduction">
    <title>Introduction</title>

    <para>In a de-coupled environment, its not always easy to let various
    components communicate with each other. In order to make this task
    slightly easier Spring Actionscript includes the <literal
    xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>
    class.</para>

    <para>The <literal
    xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>
    is a final class with only static methods. In Actionscript it is not
    possible to define an interface with static methods. In order to still
    provide an interface there does exist the <literal
    xlink:href="asdoc://org.springextensions.actionscript.core.event.IEventBus">IEventBus</literal>.
    This interface is implemented by the <literal
    xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBusFacade">EventBusFacade</literal>,
    which re-routes all of its methods to their <literal
    xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>
    equivalent. This way it is easier to mock up an <literal
    xlink:href="asdoc://org.springextensions.actionscript.core.event.IEventBus">IEventBus</literal>
    for unit testing purposes.</para>

    <section xml:id="eventbus_listening">
      <title>EventBus listening</title>

      <para>There are a number of different ways to subscribe to events that
      are dispatched through the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus:</literal></para>

      <para>The first is to listen to all events that are dispatched through
      the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>.
      This is possible through the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#addListener()">EventBus.addListener</literal>
      method. This method expects an <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.IEventBusListener">IEventBusListener</literal>
      as an argument. The <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.IEventBusListener">IEventBusListener</literal>
      looks like this:</para>

      <programlisting>public interface IEventBusListener {

 function onEvent(event:Event):void;

}</programlisting>

      <para>Every event dispatched by the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>
      will be passed into the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.IEventBusListener#onEvent()">onEvent</literal>
      method.</para>

      <para>The second method is to only listen for events of a specific type.
      Use the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#addEventListener()">EventBus.addEventListener</literal>
      for this task. The <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#addEventListener()">addEventListener</literal>
      method expects two arguments, the first is a string representing the
      event type, and the second is a Function instance which will be invoked
      with every event of the specified type.</para>

      <para>Instead of a Function it is also possible to supply a proxy
      instead. This is what the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#addEventListenerProxy()">addEventListenerProxy</literal>
      method is for. Instead of a Function this expects a <literal
      xlink:href="http://www.as3commons.org/as3-commons-reflect/asdoc/org/as3commons/reflect/MethodInvoker.html">MethodInvoker</literal>
      instance. The <literal
      xlink:href="http://www.as3commons.org/as3-commons-reflect/asdoc/org/as3commons/reflect/MethodInvoker.html">MethodInvoker</literal>
      class is part of the <literal
      xlink:href="http://www.as3commons.org/as3-commons-reflect/">as3-commons-reflect</literal>
      package.</para>

      <para>The last option is to add a listener for events of a certain
      class. To get this to happen use the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#addEventClassListener()">addEventClassListener</literal>
      or <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#addEventClassListenerProxy()">addEventClassListenerProxy</literal>
      methods. The same arguments apply to these as for their <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#addEventListener()">addEventListener</literal>
      and <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#addEventListenerProxy()">addEventListenerProxy</literal>
      neighbours, except they expect a Class instance instead of a
      type.</para>

      <para>All these methods naturally have a removal counterpart: <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#removeListener()">removeListener</literal>,
      <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#removeEventListener()">removeEventListener</literal>,
      <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#removeEventListenerProxy()">removeEventListenerProxy</literal>,
      <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#removeEventClassListener()">removeEventClassListener</literal>
      and <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#removeEventClassListenerProxy()">removeEventClassListenerProxy</literal>.</para>

      <para>To clear all types of registered eventlisteners at once simply
      call the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#removeAll()">removeAll()</literal>
      method.</para>
    </section>

    <section xml:id="eventbus_dispatching">
      <title>EventBus dispatching</title>

      <para>This is the easiest part, to dispatch an event through the
      <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>
      invoke either the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#dispatchEvent()">dispatchEvent</literal>
      or <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#dispatch()">dispatch</literal>
      methods. The former expects an Event instance while the latter expects a
      string that indicates a certain type of Event. This event will be
      created by this method and subsequently dispatched. For example:</para>

      <programlisting>EventBus.dispatchEvent(new MyCustomEvent("myCustomEventType"));</programlisting>

      <para>or</para>

      <programlisting>EventBus.dispatch("myCustomEventType");</programlisting>
    </section>

    <section xml:id="eventbus_event_handling_using_metadata_annotations">
      <title>EventBus event handling using metadata annotations</title>

      <para>To prevent a lot of boilerplate code consisting of long lists of
      addEventListener* calls, Spring Actionscript includes an alternative way
      to define event handlers for events that are dispatched through the
      <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>.</para>

      <para>Instead of adding specific listeners functions through the
      addEventListener calls simply add a bit of metadata to the particular
      method:</para>

      <programlisting><emphasis role="bold">[EventHandler]</emphasis>
protected function saveUserHandler(event:Event):void {
<lineannotation>//implementation ommitted...</lineannotation>
}</programlisting>

      <para>This is the most basic way of annotating a method and immediately
      implies certain assumptions. In this case it is assumed that the
      saveUser method will handle an event of the type "<emphasis
      role="bold">saveUser</emphasis>". Another valid method name for this
      handler could also be:</para>

      <programlisting><emphasis role="bold">[EventHandler]</emphasis>
protected function saveUser(event:Event):void {
<lineannotation>//implementation ommitted...</lineannotation>
}</programlisting>

      <para>If, for some reason, this naming convention is not desired then
      add the name of the type of the specific event to the metadata:</para>

      <programlisting><emphasis role="bold">[EventHandler(name="saveUser")]</emphasis>
protected function saveTheUserNow(event:Event):void {
<lineannotation>//implementation ommitted...</lineannotation>
}</programlisting>

      <para>By default, an event handler function is expected to have a single
      argument of type Event (or any subclass). It is however possible to let
      Spring Actionscript match the properties of the specified event with the
      arguments of the event handler. For instance, if the event passed to the
      saveUser event is not an ordinary event, but a subclass called
      SaveUserEvent with a property that is called "user" of the type "User".
      In this case an event handler with the following signature will work
      just a well:</para>

      <programlisting>[EventHandler]
protected function saveUser(user:User):void {
<lineannotation>//implementation ommitted...</lineannotation>
}</programlisting>

      <para>The property/argument matching is done by type, so this will fail
      in the case where an event has multiple properties of the same kind. If
      the SaveUserEvent should have two user properties, called userA or userB
      for example, the matching will fail. In that case it is possible to
      define the properties by name directly in the metadata:</para>

      <programlisting>[EventHandler(properties="userA,userB")]
protected function saveUser(userA:User, userB:User):void {
<lineannotation>//implementation ommitted...</lineannotation>
}</programlisting>

      <para>To annotate a handler for a certain event Class, define the fully
      qualified class name like this:</para>

      <programlisting><emphasis role="bold">[EventHandler(clazz="com.classes.events.UserEvent")]</emphasis>
protected function saveTheUserNow(event:UserEvent):void {
<lineannotation>//implementation ommitted...</lineannotation>
}</programlisting>

      <para>To enable the processing of these kinds of annotations it is
      necessary to add an instance of the <literal
      xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.EventHandlerMetaDataPostProcessor">EventHandlerMetaDataPostProcessor</literal>
      to the application context. The easiest way to do so is to add this bit
      of <abbrev>XML</abbrev> to the configuration:</para>

      <programlisting>&lt;object id="eventhandlerProcessor" class="org.springextensions.actionscript.ioc.factory.config.EventHandlerMetaDataPostProcessor"/&gt;</programlisting>

      <para>This will automatically register the processor with the
      application context.</para>

      <note>
        <para>Do not forget to add the EventHandler metadata to the compiler
        arguments: <emphasis
        role="bold">-keep-as3-metadata+=EventHandler</emphasis>. Failing to do
        so will prevent the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.EventHandlerMetaDataPostProcessor">EventHandlerMetaDataPostProcessor</literal>
        to do its work.</para>
      </note>

      <note>
        <para>Credit where credit is due: The <emphasis
        role="bold">[EventHandler]</emphasis> handling is similar to the
        <emphasis role="bold">[Mediate]</emphasis> metadata as first
        introduced by <literal xlink:href="http://cdscott.blogspot.com">Chris
        Scott</literal> in the <literal
        xlink:href="http://www.swizframework.org">Swiz Framework</literal>,
        the Spring Actionscript team both acknowledges and appreciates his
        work.</para>
      </note>
    </section>

    <section xml:id="routing_other_events_through_the_eventbus">
      <title>Routing other events through the EventBus</title>

      <para>On the other side of the spectrum there is event dispatching and a
      way to avoid having to call <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus#dispatch()">EventBus.dispatch(someEvent)</literal>
      a zillion times. For this particular goal there is the [RouteEvents]
      metadata which can be handled by the <literal
      xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.RouteEventsMetaDataPostProcessor">RouteEventsMetaDataPostProcessor</literal>.
      Let's take a look at simple example, imagine a class that is able to
      dispatch a number of events:</para>

      <programlisting>[Event(name="eventName1",type="...")]
[Event(name="eventName2",type="...")]
[Event(name="eventName3",type="...")]
public class MyClass {
  //implementation omitted..
}</programlisting>

      <para>To let Spring Actionscript catch all these events, and redispatch
      them through the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>,
      all that is necessary is the addition of the [RouteEvents]
      metadata:</para>

      <programlisting><emphasis role="bold">[RouteEvents]</emphasis>
[Event(name="eventName1",type="...")]
[Event(name="eventName2",type="...")]
[Event(name="eventName3",type="...")]
public class MyClass {
  //implementation omitted...
}</programlisting>

      <para>If not all events need to be re-routed then use the 'events'
      argument of the [RouteEvents] metadata:</para>

      <programlisting><emphasis role="bold">[RouteEvents(events="eventName1,eventName2")]</emphasis>
[Event(name="eventName1",type="...")]
[Event(name="eventName2",type="...")]
[Event(name="eventName3",type="...")]
public class MyClass {
  //implementation omitted...
}</programlisting>

      <para>And that's all there is to it, now to enable this functionality
      add this object definition to the <abbrev>XML</abbrev>
      configuration:</para>

      <programlisting>&lt;object id="routeEventsProcessor" class="org.springextensions.actionscript.ioc.factory.config.RouteEventsMetaDataPostProcessor"/&gt;</programlisting>

      <para>This will automatically register the processor with the
      application context.</para>

      <note>
        <para>Do not forget to add the RouteEvents metadata to the compiler
        arguments: <emphasis
        role="bold">-keep-as3-metadata+=RouteEvents</emphasis>. Failing to do
        so will prevent the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.RouteEventsMetaDataPostProcessor">RouteEventsMetaDataPostProcessor</literal>
        to do its work.</para>
      </note>

      <para>The combination of the <emphasis
      role="bold">[RouteEvents]</emphasis> and <emphasis
      role="bold">[EventHandler]</emphasis> enables a developer to leverage
      the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>
      without directly depending on it.</para>
    </section>

    <section>
      <title>Metadata driven <abbrev>MVC</abbrev> micro-framework</title>

      <para>Leveraging the above described classes and techniques Spring
      Actionscript offers a small metadata driven <abbrev>MVC</abbrev>
      micro-framework. These are the key components that this framework
      provides:</para>

      <itemizedlist>
        <listitem>
          <para>Fully metadata driven</para>
        </listitem>

        <listitem>
          <para>Works with regular Flash events (flash.events.Event)</para>
        </listitem>

        <listitem>
          <para>No need to implement Spring Actionscript interfaces or inherit
          from base classes</para>
        </listitem>

        <listitem>
          <para>Plays nice in multi-module environments</para>
        </listitem>
      </itemizedlist>

      <para>The framework uses metadata tags in event and command classes to
      define mappings between them and the application context as a class
      factory for the commands.</para>

      <section>
        <title>Getting started</title>

        <para>First add this object definition to the application context
        <abbrev>XML</abbrev> configuration:</para>

        <programlisting>&lt;object id="mvcFactory" class="org.springextensions.actionscript.core.mvc.MVCControllerObjectFactoryPostProcessor"/&gt;</programlisting>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.core.mvc.MVCControllerObjectFactoryPostProcessor">MVCControllerObjectFactoryPostProcessor</literal>
        is an <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectFactoryPostProcessor">IObjectFactoryPostProcessor</literal>
        implementation that takes care of all the metadata processing and
        event/command mapping.</para>

        <para>This factory postprocessor first checks for the existence of an
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.core.mvc.IMVCEventObjectPostProcessor">IMVCEventObjectPostProcessor</literal>
        implementation in the application context, when none is found it
        creates an instance of the <literal
        xlink:href="asdoc://org.springextensions.actionscript.core.mvc.MVCRouteEventsMetaDataProcessor">MVCRouteEventsMetaDataProcessor</literal>
        class and adds it to the application context singleton cache. This
        allows for the events postprocessor to be overridden by another
        implementation.</para>

        <para>After that the factory postprocessor checks if an <literal
        xlink:href="asdoc://org.springextensions.actionscript.core.mvc.IController">IController</literal>
        implementation exists in the application context, of not a
        <literal>Controller</literal> instance is created and added to the
        context so, if necessary, the <literal
        xlink:href="asdoc://org.springextensions.actionscript.core.mvc.IController">IController</literal>
        instance can be overridden again.</para>

        <para>This takes care of the preparatory work, now all that remains is
        defining the event/command mappings.</para>
      </section>

      <section>
        <title>Annotating classes that dispatch MVC events</title>

        <para>Annotating components and classes that dispatch events that need
        to be mapped to a command is almost the same as annotating them for
        dispatch through the <literal
        xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>
        (the <literal
        xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>
        is used by this <abbrev>MVC</abbrev> framework as the main
        communication pipeline). So, let's have a simple example:</para>

        <programlisting><emphasis role="bold">[RouteMVCEvents]</emphasis>
[Event(name="someEventType","flash.events.Event")]
public class SomeClassThatDispatchesMVCEvents {
  <lineannotation>//implementation ommitted...</lineannotation>
}</programlisting>

        <para>This means that <emphasis role="bold">[RouteEvents]</emphasis>
        and <emphasis role="bold">[RouteMVCEvents]</emphasis> metadata can be
        combined. (A class could even be annotated with both types of
        metadata.)</para>

        <para>This is all that is necessary for the event side of things of
        the <abbrev>MVC</abbrev> functionality.</para>
      </section>

      <section>
        <title>Annotating classes that act as MVC commands</title>

        <para>To define a command that is to be triggered by the
        aforementioned event can be annotated in its simplest form like
        this:</para>

        <programlisting><emphasis role="bold">[Command(eventType="someEventType")]</emphasis>
public class CommandClass {
  function execute():void {
    <lineannotation>//implementation ommitted...</lineannotation>
  }
  <lineannotation>//further implementation ommitted...</lineannotation>
}</programlisting>

        <para>When the command is triggered by a certain event Class, define
        the class like this:</para>

        <programlisting><emphasis role="bold">[Command(eventClass="com.events.CustomEvent")]</emphasis>
public class CommandClass {
  function execute():void {
    <lineannotation>//implementation ommitted...</lineannotation>
  }
  <lineannotation>//further implementation ommitted...</lineannotation>
}</programlisting>

        <para>The command class does not need to implement any kind of
        interfaces or inherit from any base classes. By default the
        <abbrev>MVC</abbrev> framework will assume that a method called
        <emphasis role="bold">execute</emphasis> needs to be invoked. When a
        different method name is needed this can be defined in the metadata
        tag:</para>

        <programlisting>[Command(eventType="someEventType",<emphasis
            role="bold">executeMethod="process"</emphasis>)]
public class CommandClass {
  function process():void {
    <lineannotation>//implementation ommitted...</lineannotation>
  }
  <lineannotation>//further implementation ommitted...</lineannotation>
}</programlisting>

        <para>When the execution method needs to receive a reference to the
        event instance it will be automatically mapped:</para>

        <programlisting>[Command(eventType="someEventType",<emphasis
            role="bold">executeMethod="process"</emphasis>)]
public class CommandClass {
  function process(event:Event):void {
    <lineannotation>//implementation ommitted...</lineannotation>
  }
  <lineannotation>//further implementation ommitted...</lineannotation>
}</programlisting>

        <para>Properties on the event can be automatically mapped to the
        method arguments as well. Imagine for instance this event
        class:</para>

        <programlisting>public class CustomEvent extends flash.events.Event {
  public static const EVENT_ID:String = "someEventType";

  public var user:User;
  <lineannotation>//further implementation ommitted...</lineannotation>

}</programlisting>

        <para>If the command class has this definition, the property will be
        mapped automatically:</para>

        <programlisting>[Command(eventType="someEventType",executeMethod="process")]
public class CommandClass {
  function process(<emphasis role="bold">user:User</emphasis>):void {
    <lineannotation>//implementation ommitted...</lineannotation>
  }
  <lineannotation>//further implementation ommitted...</lineannotation>
}</programlisting>

        <para>The event properties can also be mapped to properties on the
        command:</para>

        <programlisting>[Command(eventType="someEventType",executeMethod="process")]
public class CommandClass {

  public var user:User;

  function process():void {
    <lineannotation>//implementation ommitted...</lineannotation>
  }
  <lineannotation>//further implementation ommitted...</lineannotation>
}</programlisting>

        <para>The mapped event properties can also be explicitly named:</para>

        <programlisting>[Command(eventType="someEventType",executeMethod="process",properties="userA,userB")]
public class CommandClass {

  function process(userA:User, userB:User):void {
    <lineannotation>//implementation ommitted...</lineannotation>
  }
  <lineannotation>//further implementation ommitted...</lineannotation>
}</programlisting>

        <para>Now all that is left is to add object definitions for each
        command that is used to the application context <abbrev>XML</abbrev>
        configuration:</para>

        <programlisting>&lt;object id="myCommand" class="com.classes.commands.CommandClass"/&gt;</programlisting>
        
        <para>Or, alternatively, every command class can be annotated with the [Component] metadata and thus will be
        picked up by the class scanning system:</para>
        
        <programlisting>[Component]
[Command(eventType="someEventType",executeMethod="process")]
public class CommandClass {
}</programlisting>

	<para>For further information on the class scanning system see section '<link linkend="the_component_scanner">The Component scanner and class scanning system</link>'</para>

        <note>
          <para>The application context can now be used as the main command
          classfactory, leveraging all of its rich <abbrev>DI</abbrev>
          functionality. Services, models and other dependencies can be
          easily defined and injected.</para>
        </note>
      </section>
    </section>
  </section>
</chapter>
