<?xml version="1.0" encoding="UTF-8"?>
<chapter annotations="" version="5.0" xml:id="container-documentation"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/1998/Math/MathML"
         xmlns:ns4="http://www.w3.org/2000/svg"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <title>The Inversion of Control (<abbrev>IoC</abbrev>) container</title>

  <section xml:id="container_introduction">
    <title>Introduction</title>

    <para>This chapter covers the Spring Actionscript Framework's
    implementation of the Inversion of Control (<abbrev>IoC</abbrev>)
    principle.</para>

    <para>The <literal
    xlink:href="asdocpackage://org.springextensions.actionscript.context">org.springextensions.actionscript.context</literal>
    and <literal
    xlink:href="asdocpackage://org.springextensions.actionscript.ioc.factory.xml">org.springextensions.actionscript.ioc.factory.xml</literal>
    packages provide the basis for the Spring Actionscript Framework's
    <abbrev>IoC</abbrev> container.</para>

    <para>The <literal
    xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>
    or <literal
    xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>
    are the classes that any programmer starting out with Spring Actionscript
    will encounter as the first pieces of code from the framework that they
    will need to use. The classes are nearly identical, <literal os=""
    xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>
    only adds Flex specific support, such as for the ArrayCollection.</para>

    <para>These classes take care of loading and parsing of a configuration
    file, after which they are able to instantiate, assemble and otherwise
    manage objects.</para>

    <para>In this chapter we are going to describe how to set up a
    configuration file, create an application context and use it to
    instantiate objects.</para>

    <section xml:id="basics_containers_and_objects">
      <title>Basics - containers and objects</title>

      <para>The objects that are managed by the Spring Actionscript
      <abbrev>IoC</abbrev> container, and the dependencies between them, are
      reflected in the <emphasis>configuration metadata</emphasis> used by a
      container.</para>

      <section xml:id="the_container">
        <title>The container</title>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>
        or <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>
        classes are the central <abbrev>IoC</abbrev> container objects in
        Spring Actionscript. Their responsibilities include instantiating or
        sourcing application objects, configuring such objects, and assembling
        the dependencies between these objects.</para>

        <para>They inherit from <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.XMLObjectFactory">XMLObjectFactory</literal>
        which allows you to express the objects that compose your application,
        and the doubtless rich interdependencies between such objects, in
        terms of <abbrev>XML</abbrev>. The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.XMLObjectFactory">XMLObjectFactory</literal>
        takes this <abbrev>XML</abbrev> <emphasis>configuration
        metadata</emphasis> and uses it to create a fully configured system or
        application.</para>

        <para>So what does this mean in plain English?</para>

        <para>An instance of <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>
        or <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>
        can read an <abbrev>XML</abbrev> file containing a
        <emphasis>description</emphasis> of the dependencies of your business
        objects and manage these dependencies. For instance, do all your
        business object need a reference to your model? But you want to be
        certain that they all receive the <emphasis>same </emphasis>reference
        without having to depend on a singleton object?</para>

        <para>This is where the <abbrev>IoC</abbrev> container comes
        in.</para>

        <section xml:id="configuration_metadata">
          <title>Configuration metadata</title>

          <para>Spring Actionscript supports configurations defined in
          <abbrev>XML</abbrev> or <abbrev>MXML</abbrev>. When using
          <abbrev>XML</abbrev>-based configuration metadata, you write object
          definitions for those objects that you want the Spring Actionscript
          <abbrev>IoC</abbrev> container to manage, and then let the container
          do its stuff. Spring Actionscript configuration consists of at least
          one object definition that the container must manage, but typically
          there will be more than one object definition. These object
          definitions are configured as <emphasis role="bold"><literal
          xlink:href="dtd://anchor_objectType">&lt;object/&gt;</literal></emphasis>
          elements inside a top-level <emphasis role="bold"><literal
          xlink:href="dtd://anchor_objectsType">&lt;objects/&gt;</literal></emphasis>
          element.</para>

          <para>(See <link
          linkend="composing_mxml_based_configuration_metadata">Composing MXML
          based configuration metadata</link> for how to perform this task
          using <abbrev>MXML</abbrev> instead).</para>

          <para>These object definitions correspond to the actual objects that
          make up your application, they <emphasis>describe</emphasis> how
          these objects need to be instantiated and configured.</para>

          <para><emphasis>Find below an example of the basic structure of
          <abbrev>XML</abbrev>-based configuration metadata.</emphasis></para>

          <para><programlisting>&lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;objects xmlns="http://www.springactionscript.org/schema/objects"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springactionscript.org/schema/objects
                        http://www.springactionscript.org/schema/objects/spring-actionscript-objects-1.0.xsd"&gt;
          
    &lt;object id="..." class="..."&gt;
    <lineannotation>&lt;!-- collaborators and configuration for this object go here --&gt;</lineannotation>
    &lt;/object&gt;
    &lt;object id="..." class="..."&gt;
    <lineannotation>&lt;!-- collaborators and configuration for this object go here --&gt;</lineannotation>
    &lt;/object&gt;

    <lineannotation>&lt;!-- more object definitions go here --&gt;</lineannotation>
&lt;/objects&gt;</programlisting></para>
        </section>
      </section>

      <section xml:id="instantiating_a_container">
        <title>Instantiating a container</title>

        <para>Instantiating a Spring Actionscript <abbrev>IoC</abbrev>
        container is straightforward.</para>

        <para><programlisting>var applicationContext:<literal
              xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal> = new <literal
              xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>();
applicationContext.addConfigLocation("application-context.xml");
applicationContext.addEventListener(Event.COMPLETE, handleComplete);
applicationContext.load();</programlisting></para>

        <para>The application-xml file in the above listing resides either on
        a remote server or a local file. Depending on the application in
        question being a Flex/Flash or AIR application. Either way, the
        <abbrev>XML</abbrev> file is being loaded using a URLLoader object.
        This means that this operation is asynchronous i.e. The application
        can't know beforehand when this it is finished. Hence the
        addEventListener call: once container has fully loaded the
        <abbrev>XML</abbrev> file and has successfully parsed it, the complete
        event is fired and the handleComplete method will be called.</para>

        <para>To avoid hard coding the URL to the configuration file in the
        application source it is recommended to pass this a
        <emphasis>flashvar</emphasis> into the Flex application. These
        flashvars can be defined in Flex Builder in the HTML template. This
        template can be found in the project directory root and is called
        <emphasis role="bold">html-template</emphasis>. In this directory is
        resides a file called <emphasis
        role="bold">index.template.html</emphasis>.</para>

        <para>Below is an example of how a flashvar defining the
        application-context.xml location, this example shows all the code
        between the <emphasis role="bold">&lt;body&gt;</emphasis> tag of the
        template. The relevant pieces of code have been marked in bold.</para>

        <programlisting>&lt;script language="JavaScript" type="text/javascript"&gt;
&lt;!--
<lineannotation>// Version check for the Flash Player that has the ability to start Player Product Install (6.0r65)</lineannotation>
var hasProductInstall = DetectFlashVer(6, 0, 65);

<lineannotation>// Version check based upon the values defined in globals</lineannotation>
var hasRequestedVersion = DetectFlashVer(requiredMajorVersion, requiredMinorVersion, requiredRevision);

if ( hasProductInstall &amp;&amp; !hasRequestedVersion ) {
    <lineannotation>// DO NOT MODIFY THE FOLLOWING FOUR LINES
    // Location visited after installation is complete if installation is required</lineannotation>
    var MMPlayerType = (isIE == true) ? "ActiveX" : "PlugIn";
    var MMredirectURL = window.location;
    document.title = document.title.slice(0, 47) + " - Flash Player Installation";
    var MMdoctitle = document.title;

    AC_FL_RunContent(
        "src", "playerProductInstall",
        "FlashVars", "MMredirectURL="+MMredirectURL+'&amp;MMplayerType='+MMPlayerType+'&amp;MMdoctitle='+MMdoctitle+"",
        "width", "${width}",
        "height", "${height}",
    "align", "middle",
    "id", "${application}",
    "quality", "high",
    "bgcolor", "${bgcolor}",
    "name", "${application}",
    "allowScriptAccess","sameDomain",
    "type", "application/x-shockwave-flash",
    "pluginspage", "http://www.adobe.com/go/getflashplayer"
    );
} else if (hasRequestedVersion) {
    <lineannotation>// if we've detected an acceptable version
    // embed the Flash Content SWF when all tests are passed</lineannotation>
    AC_FL_RunContent(
            "src", "${swf}",
            <emphasis role="bold">"FlashVars", "ContextURL=application-context.xml",</emphasis>
            "width", "${width}",
            "height", "${height}",
            "align", "middle",
            "id", "${application}",
            "quality", "high",
            "bgcolor", "${bgcolor}",
            "name", "${application}",
            "allowScriptAccess","sameDomain",
            "type", "application/x-shockwave-flash",
            "pluginspage", "http://www.adobe.com/go/getflashplayer"
    );
  } else {  <lineannotation>// flash is too old or we can't detect the plugin</lineannotation>
    var alternateContent = 'Alternate HTML content should be placed here. '
      + 'This content requires the Adobe Flash Player. '
       + '&lt;a href=http://www.adobe.com/go/getflash/&gt;Get Flash&lt;/a&gt;';
    document.write(alternateContent);  // insert non-flash content
  }
// --&gt;
&lt;/script&gt;
&lt;noscript&gt;
      &lt;object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"
            id="${application}" width="${width}" height="${height}"
            codebase="http://fpdownload.macromedia.com/get/flashplayer/current/swflash.cab"&gt;
            <emphasis role="bold">&lt;param name="FlashVars" value="ContextURL=application-context.xml" /&gt;</emphasis>
            &lt;param name="movie" value="${swf}.swf" /&gt;
            &lt;param name="quality" value="high" /&gt;
            &lt;param name="bgcolor" value="${bgcolor}" /&gt;
            &lt;param name="allowScriptAccess" value="sameDomain" /&gt;
            &lt;embed src="${swf}.swf" quality="high" bgcolor="${bgcolor}"
                width="${width}" height="${height}" name="${application}" align="middle"
                play="true"
                loop="false"
                quality="high"
                <emphasis role="bold">flashvars="ContextURL=application-context.xml"</emphasis>
                allowScriptAccess="sameDomain"
                type="application/x-shockwave-flash"
                pluginspage="http://www.adobe.com/go/getflashplayer"&gt;
            &lt;/embed&gt;
    &lt;/object&gt;
&lt;/noscript&gt;</programlisting>

        <para>To access the flashvar parameters add an eventhandler for the
        preinitialize event in your application, like so:</para>

        <programlisting>addEventListener(FlexEvent.PREINITIALIZE,handlePreInit);</programlisting>

        <para>or in MXML:</para>

        <programlisting>&lt;mx:Application preinitialize="handlePreInit(event)"/&gt;</programlisting>

        <para>Then in the event handling method retrieve the flashvar
        parameter like this:</para>

        <programlisting>private function handlePreInit(event:FlexEvent):void {

    <emphasis role="bold">_contextURL</emphasis> = parameters['ContextURL'];
}</programlisting>

        <para>Then later on (after the APPLICATION_COMPLETE event) the context
        URL can be fed to the application context instance again:</para>

        <programlisting>var applicationContext:<literal
            xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal> = new <literal
            xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>();
applicationContext.addConfigLocation(<emphasis role="bold">_contextURL</emphasis>);
applicationContext.addEventListener(Event.COMPLETE, handleComplete);
applicationContext.load();</programlisting>

        <section xml:id="composing_xml_based_configuration">
          <title>Composing <abbrev>XML</abbrev>-based configuration
          metadata</title>

          <para>It can often be useful to split up container definitions into
          multiple <abbrev>XML</abbrev> files. One way to then load an
          application context which is configured from all these
          <abbrev>XML</abbrev> fragments is to use the application context
          constructor which takes multiple resource locations. Also, after
          construction of the container, more locations can be added with the
          <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.XMLObjectFactory#addConfigLocation()">addConfigLocation</literal>()
          method.</para>

          <para>Generally, the Spring Actionscript team prefers the above
          approach, since it keeps container configuration files unaware of
          the fact that they are being combined with others. An alternate
          approach is to use one or more occurrences of the <emphasis
          role="bold"><literal wordsize=""
          xlink:href="dtd://anchor_importType">&lt;import/&gt;</literal></emphasis>
          element to load object definitions from another file (or files).
          Let's look at a sample:</para>

          <programlisting>&lt;objects&gt;

    <emphasis role="bold">&lt;import file="services.xml"/&gt;
    &lt;import file="resources/messageSource.xml"/&gt;
    &lt;import file="/resources/themeSource.xml"/&gt;</emphasis>

    &lt;object id="object1" class="..."/&gt;
    &lt;object id="object2" class="..."/&gt;

&lt;/objects&gt;</programlisting>

          <para>The contents of the files being imported must be valid
          <abbrev>XML</abbrev> object definition files according to the Spring
          Actionscript schema, including the top level <emphasis role="bold"
          xlink:href="dtd://anchor_objectsType">&lt;objects/&gt;</emphasis>
          element.</para>
        </section>

        <section>
          <title>the object definition</title>

          <para><emphasis role="bold">&lt;object/&gt;</emphasis> elements can
          have a number of attributes that determine various properties and
          behaviors of an object, its creation and wiring. Here's a list of
          all these properties with a link to their respective documentation
          sections:</para>

          <itemizedlist>
            <listitem>
              <para><link
              linkend="object_definition_inheritance">abstract</link></para>
            </listitem>

            <listitem>
              <para><link linkend="autowiring_objects">autowire</link></para>
            </listitem>

            <listitem>
              <para><link
              linkend="autowiring_objects">autowire-candidate</link></para>
            </listitem>

            <listitem>
              <para><link linkend="the_objects">class</link></para>
            </listitem>

            <listitem>
              <para><link
              linkend="ensuring_dependency_injection_with_dependency_check">dependency-check</link></para>
            </listitem>

            <listitem>
              <para><link linkend="using_depends_on">depends-on</link></para>
            </listitem>

            <listitem>
              <para><link
              linkend="disposing_managed_objects">destroy-method</link></para>
            </listitem>

            <listitem>
              <para><link
              linkend="instantiation_using_a_static_factory_method">factory-method</link></para>
            </listitem>

            <listitem>
              <para><link
              linkend="instantiation_using_a_factory_method_on_a_different_instance">factory-object</link></para>
            </listitem>

            <listitem>
              <para><link linkend="naming_objects">id</link></para>
            </listitem>

            <listitem>
              <para><link
              linkend="initialization_callbacks">init-method</link></para>
            </listitem>

            <listitem>
              <para><link
              linkend="lazilyinstantiated_beans">lazy-init</link></para>
            </listitem>

            <listitem>
              <para><link
              linkend="object_definition_inheritance">parent</link></para>
            </listitem>

            <listitem>
              <para><link linkend="autowiring_objects">primary</link></para>
            </listitem>

            <listitem>
              <para><link linkend="object_scopes">scope</link></para>
            </listitem>

            <listitem>
              <para><link linkend="object_scopes">singleton</link>
              (deprecated, use scope attribute instead)</para>
            </listitem>

            <listitem>
              <para><link
              linkend="autowiring_stage_components">skip-metadata</link></para>
            </listitem>

            <listitem>
              <para><link
              linkend="customizing_objects_using_objectpostprocessors">skip-postprocessors</link></para>
            </listitem>

            <listitem>
              <para><link
              linkend="object_definition_inheritance">template</link></para>
            </listitem>
          </itemizedlist>

          <para>These element attributes will be mapped onto <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.IObjectDefinition">IObjectDefiniton</literal>
          instances after the <abbrev>XML</abbrev> has been parsed by the
          application context. Object definitions can be defined in <link
          linkend="the_objects">XML</link>, <link
          linkend="composing_mxml_based_configuration_metadata">MXML</link> or
          <link
          linkend="the_component_scanner_introduction">annotations</link>.
          Object definitions can be augmented with <link
          linkend="constructor_injection">constructor</link>, <link
          linkend="setter_injection">property</link> and <link
          linkend="method_invocations">method invocation</link>
          definitions.</para>
        </section>
      </section>

      <section xml:id="embedding_the_xml_metadata">
        <title>Embedding the XML metadata</title>

        <para>In the case where an external <abbrev>XML</abbrev> file is not
        desirable or practical Spring Actionscript also allows you to embed
        the <abbrev>XML</abbrev> metadata file in the application.</para>

        <para>To do so embed the <abbrev>XML</abbrev> file like this:</para>

        <programlisting>[Bindable]
[Embed(source="application-context.xml",mimeType ="application/octet-stream")]
public var contextConfig:Class;</programlisting>

        <note>
          <para>For more information about embedding files visit this link:
          <literal
          xlink:href="http://livedocs.adobe.com/flex/3/html/help.html?content=embed_3.html"
          xlink:title="Advanced Flex Programming / Embedding Assets ">http://livedocs.adobe.com/flex/3/html/help.html?content=embed_3.html</literal></para>
        </note>

        <para>After that the way to add the configuration location is slightly
        different:</para>

        <programlisting>var applicationContext:<literal
            xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal> = new <literal
            xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>();
<emphasis role="bold">applicationContext.addEmbeddedConfig(contextConfig);</emphasis>
applicationContext.load();
</programlisting>

        <para>Notice that we no longer need the <emphasis
        role="bold">Event.COMPLETE</emphasis> handler, since the
        configurations are embedded they will be loaded and parsed
        synchronously, so after invoking <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.XMLObjectFactory#addEmbeddedConfig()">addEmbeddedConfig()</literal>
        once or more and calling <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.XMLObjectFactory#load()">load()</literal>
        the application context will be ready for use immediately.</para>

        <note>
          <para>Of course, if you mix embedded and external metadata you will
          need to keep the <emphasis role="bold">Event.COMPLETE</emphasis>
          handler and <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.XMLObjectFactory#load()">load()</literal>
          invocation for obvious reasons.</para>
        </note>

        <para>And that's all there is to it!</para>

        <section xml:id="declaring_embedded_import_files">
          <title>Declaring embedded import files</title>

          <para>If your embedded configuration file also contains import
          declarations you will have to change the markup slightly to let
          Spring Actionscript know where to find them. But first add your
          import configurations like this:</para>

          <programlisting>[Bindable]
[Embed(source="services.xml",mimeType ="application/octet-stream")]
public var <emphasis role="bold">servicesContext</emphasis>:Class;

[Bindable]
[Embed(source="resources/messageSource.xml",mimeType ="application/octet-stream")]
public var <emphasis role="bold">messageSourceContext</emphasis>:Class;

[Bindable]
[Embed(source="/resources/themeSource.xml",mimeType ="application/octet-stream")]
public var <emphasis role="bold">themeSourceContext</emphasis>:Class;</programlisting>

          <para>Then inside your main configuration file, change the import
          markup like this:</para>

          <programlisting>&lt;objects&gt;

    <emphasis role="bold">&lt;import file="servicesContext" type="class"/&gt;
    &lt;import file="messageSourceContext" type="class"/&gt;
    &lt;import file="themeSourceContext" type="class"/&gt;</emphasis>

    &lt;object id="object1" class="..."/&gt;
    &lt;object id="object2" class="..."/&gt;

&lt;/objects&gt;</programlisting>

          <para>And again, that's all there is to it!</para>

          <note>
            <para>Make sure to add the embedded Class instances as properties
            of your Application object, this is the place where Spring
            Actionscript will look for these property names. If it fails to
            find the specified names an Error will be thrown. Also, because
            this functionality is depended on the Flex framework, it is only
            available when using the FlexXMLApplicationContext class, in other
            cases the type='class' attribute will be ignored.</para>
          </note>
        </section>
      </section>

      <section xml:id="external_property_files">
        <title>External property files</title>

        <para>In some scenarios it might be useful to store certain properties
        of the config <abbrev>XML</abbrev> file externally so that you can
        easily change them without having to wade through the entire
        configuration file or if you want to re-use certain global values in
        different parts of the configuration, such as path data or
        URLs.</para>

        <para>The application context allows you to specify external
        properties in separate Ant-like <emphasis>*.properties</emphasis>
        files.</para>

        <para>You can then define property placeholders in your config files
        with the <emphasis role="bold">${...}</emphasis> syntax. Here's an
        example. Note that the path to the *.properties file is relative to
        the path of the configuration file.</para>

        <programlisting>&lt;objects&gt;

  <emphasis role="bold">&lt;property file="strings.properties" /&gt;</emphasis>

  &lt;object id="string1" class="String"&gt;
    &lt;constructor-arg value="<emphasis role="bold">${s1}</emphasis>"/&gt;
  &lt;/object&gt;
 
  &lt;object id="string2" class="String"&gt;
    &lt;constructor-arg value="<emphasis role="bold">${s2}</emphasis>"/&gt;
  &lt;/object&gt;

&lt;/objects&gt;</programlisting>

        <para>And the strings.properties file contents would look like
        this:</para>

        <programlisting>s1=First string
s2=Second string
</programlisting>

        <para>Its also possible to combine property values, that way a
        property value can be injected with other values, for example:</para>

        <programlisting>s1=First String and {$s2}
s2=Second string</programlisting>

        <note>
          <para>To prevent the properties file from being cached by the web
          browser the <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.XMLObjectFactory">XMLObjectFactory</literal>
          by default will suffix the <abbrev>URL</abbrev> with a random
          number. To turn this off for a specified property file use the
          prevent-cache attribute. For example: &lt;property
          file="strings.properties" <emphasis
          role="bold">prevent-cache="false"</emphasis>/&gt;.</para>
        </note>

        <note>
          <para>By default the properties loader will throw an error if a
          properties file could not be loaded, to ignore the error and resume
          loading set the required attribute to false: &lt;property
          file="strings.properties" <emphasis
          role="bold">required="false"</emphasis>/&gt;</para>
        </note>

        <section xml:id="define_external_properties_explicitly">
          <title>Define external properties explicitly</title>

          <para>If you don't need an external file to store your properties
          in, yet you would like to define global properties to be used
          throughout your configuration, its also possible to define the
          property values directly on the &lt;property/&gt; tag:</para>

          <programlisting>&lt;property name="s1" value="First string"/&gt;
&lt;property name="s2" value="Second string"/&gt;</programlisting>

          <para>And, of course, here it is also possible to combine property
          values:</para>

          <programlisting>&lt;property name="s1" value="First string and {$s2}"/&gt;
&lt;property name="s2" value="Second string"/&gt;</programlisting>

          <note>
            <para>The file attribute will take precedence over the name and
            value attributes, so when both are declared the name and value
            attributes will be ignored.</para>
          </note>
        </section>

        <section>
          <title>Flashvars converted to properties</title>

          <para>The <literal
          xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>
          will automatically add any flashvars that were passed to the
          application to its properties collection. The name of the flashvar
          can then be used in the same way as an application setting property.
          For example: <emphasis
          role="bold">${application.myFlashVar}</emphasis>.</para>

          <para>The class responsible for this is the <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.flex.FlexPropertyPlaceholderConfigurer">FlexPropertyPlaceholderConfigurer</literal>.
          For more about the application setting read <literal
          linkend="flex_application_settings">this section</literal>.</para>
        </section>
      </section>

      <section xml:id="the_objects">
        <title>The objects</title>

        <para>A Spring Actionscript <abbrev>IoC</abbrev> container manages one
        or more objects. These objects are created using the configuration
        metadata that has been supplied to the container (typically in the
        form of <abbrev>XML</abbrev> <emphasis role="bold"><literal
        xlink:href="dtd://anchor_objectsType">&lt;objects/&gt;</literal></emphasis>
        definitions).</para>

        <para>Within the container itself, these object definitions are
        represented as <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.ObjectDefinition">ObjectDefinition</literal>
        objects, which contain (among other information) the following
        metadata:</para>

        <table audience="" border="1" style="">
          <caption>The object definition</caption>

          <thead>
            <tr>
              <th>Feature</th>

              <th>Explained in...</th>
            </tr>
          </thead>

          <tr>
            <td>class</td>

            <td><link linkend="instantiating_objects">Instantiating
            objects</link></td>
          </tr>

          <tr>
            <td>name</td>

            <td><link linkend="naming_objects">Naming objects</link></td>
          </tr>

          <tr>
            <td>constructor arguments</td>

            <td><link linkend="injecting_dependencies">Injecting
            dependencies</link></td>
          </tr>

          <tr>
            <td>properties</td>

            <td><link linkend="injecting_dependencies">Injecting
            dependencies</link></td>
          </tr>

          <tr>
            <td>autowiring mode</td>

            <td><link linkend="autowiring_objects">Autowiring
            collaborators</link></td>
          </tr>

          <tr>
            <td>lazy-initialization mode</td>

            <td><link linkend="lazilyinstantiated_beans">Lazily-instantiated
            objects</link></td>
          </tr>

          <tr>
            <td>initialization method</td>

            <td><link linkend="initialization_callbacks">Initialization
            callbacks</link></td>
          </tr>
        </table>
      </section>

      <section xml:id="naming_objects">
        <title>Naming objects</title>

        <para>Every object has one or more ids (also called identifiers, or
        names; these terms refer to the same thing). These ids must be unique
        within the container the object is hosted in.</para>

        <para>When using <abbrev>XML</abbrev>-based configuration metadata,
        you use the 'id' attribute to specify the object identifier(s). The
        'id' attribute allows you to specify exactly one id, and as it is a
        real <abbrev>XML</abbrev> element ID attribute, the
        <abbrev>XML</abbrev> parser is able to do some extra validation when
        other elements reference the id; as such, it is the preferred way to
        specify an object id. However, the <abbrev>XML</abbrev> specification
        does limit the characters which are legal in <abbrev>XML</abbrev>
        IDs.</para>
      </section>

      <section xml:id="instantiating_objects">
        <title>Instantiating objects</title>

        <para>An object definition essentially is a recipe for creating one or
        more objects. The container looks at the recipe for a named object
        when asked, and uses the configuration metadata encapsulated by that
        object definition to create (or acquire) an actual object.</para>

        <para>If you are using <abbrev>XML</abbrev>-based configuration
        metadata, you can specify the type (or class) of the object that is to
        be instantiated using the 'class' attribute of the <emphasis
        role="bold"><literal
        xlink:href="dtd://anchor_objectType">&lt;object/&gt;</literal></emphasis>
        element. This 'class' attribute (which internally eventually boils
        down to being a Class property on a <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.ObjectDefinition">ObjectDefinition</literal>
        instance) is normally mandatory (see Section "<literal
        xlink:href="#object_definition_inheritance">Object definition
        inheritance</literal>" for the exception) and is used for one of two
        purposes. The class property specifies the class of the object to be
        constructed in the common case where the container itself directly
        creates the object by calling its constructor (somewhat equivalent to
        Actionscript code using the 'new' operator). In the less common case
        where the container invokes a static, factory method on a class to
        create the object, the class property specifies the actual class
        containing the static factory method that is to be invoked to create
        the object (the type of the object returned from the invocation of the
        static factory method may be the same class or another class entirely,
        it doesn't matter).</para>

        <section xml:id="instantiation_through_a_parent_factory">
          <title>Instantiation through a parent factory</title>

          <para>Object factories can form a hierarchy through the <literal
          xlink:arcrole=""
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory#parent">parent</literal>
          property of an <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory">IObjectFactory</literal>
          implementation such as the <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.support.AbstractObjectFactory"
          xml:base="">AbstractObjectFactory</literal>. By assigning another
          <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory">IObjectFactory</literal>
          instance to this parent property the <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory#getObject()">getObject()</literal>
          method will first see if the current object factory can create the
          requested object instance, if no appropriate <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.ObjectDefinition">ObjectDefinition</literal>
          can be found it will request it from its parent factory.</para>

          <section xml:id="a_simple_example_of_an_application_context_hierarchy">
            <title>A simple example of an application context
            hierarchy</title>

            <para>Imagine a scenario with two application contexts. One is
            created by the main application and the other is created inside a
            module that is loaded at a later time.</para>

            <para>We will refer to the first as <emphasis
            role="bold">application context</emphasis> and the latter as
            <emphasis role="bold">module context</emphasis>.</para>

            <para>Now imagine the configuration of the application context to
            look like this:</para>

            <programlisting>&lt;objects&gt;

 &lt;object class="com.myclasses.MyObject" id="myObject" scope="singleton"/&gt;
 
 &lt;object class="com.myclasses.MyOtherObject" id="myOtherObject" scope="prototype"/&gt;

&lt;/objects&gt;</programlisting>

            <para>And the module context looking like this:</para>

            <programlisting>&lt;objects&gt;

 &lt;object class="com.myclasses.moduleimplementations.MyOtherObject" id="myOtherObject" scope="prototype"/&gt;

&lt;/objects&gt;</programlisting>

            <para>When the module context is created, we will set the
            application context as its parent:</para>

            <programlisting>var moduleContext:XMLApplicationContext = new XMLApplicationContext("module-context.xml");
moduleContext.parent = applicationContext;</programlisting>

            <para>The result of this is that, when an object with id <emphasis
            role="bold">myOtherObject</emphasis> is requested from the
            application context, you will receive an instance of type
            <emphasis>com.myclasses.MyOtherObject</emphasis>. However, when
            you request the same object id from the module context, you will
            receive an instance of type
            <emphasis>com.myclasses.moduleimplementations.MyOtherObject</emphasis>.</para>

            <para>Next, we change both configurations slightly, add some
            dependencies and show how to override those dependencies in a the
            module configuration.</para>

            <para>Here's how the application context's configuration
            looks:</para>

            <programlisting>&lt;objects&gt;

 &lt;object class="com.myclasses.MyObject" id="myObject" scope="singleton"/&gt;
 
 &lt;object class="com.myclasses.MyOtherObject" id="myOtherObject" scope="prototype"&gt;
  &lt;property name="dependency" ref="<emphasis role="bold">myDependency</emphasis>"/&gt;
 &lt;/object&gt;
 
 &lt;object class="com.dependencies.MyDependency" id="<emphasis role="bold">myDependency</emphasis>"/&gt;

&lt;/objects&gt;</programlisting>

            <para>Now requesting an object with id <emphasis
            role="bold">myOtherObject</emphasis> from the application context
            will yield you an instance of type
            <emphasis>com.myclasses.MyOtherObject</emphasis> with a
            <emphasis>dependency</emphasis> property value set to an instance
            of type <emphasis>com.dependencies.MyDependency</emphasis>.</para>

            <para>After that we change the module context configuration to
            look like this:</para>

            <programlisting>&lt;objects&gt;

 &lt;object class="com.moduledependencies.MyDependency" id="<emphasis
                role="bold">myDependency</emphasis>"/&gt;

&lt;/objects&gt;</programlisting>

            <para>When we subsequently request an object with id myOtherObject
            from the module context the result will be an instance of type
            <emphasis>com.myclasses.MyOtherObject</emphasis> with a
            <emphasis>dependency</emphasis> property value set to an instance
            of type
            <emphasis>com.moduledependencies.MyDependency</emphasis>.</para>

            <note>
              <para>Overriding references like this will only work on objects
              that are scoped as <emphasis>prototype</emphasis>, this is
              because its very probable that the object has already been
              cached by the parent context when requested, and injecting
              singletons created by the parent with
              <emphasis>dependencies</emphasis> created by the
              <emphasis>module</emphasis> context will suddenly put a
              dependency from the application context on the module context,
              which is undesirable.</para>
            </note>

            <para>It is also possible to replace properties with values that
            are available in the parent context, but this is not enabled by default.
			To enable this, the "useParentObjectFactoryPostProcessors" on the child
			context must be set to "true". (note: as the name of this property suggests,
			all ObjectFactoryPostProcessors defined in parent contexts will be applied
			to the child context. The PropertyPlaceholderConfigurer that is responsible
			for replacing property placeholders is one of them.)
			</para>

            <para>So if the application context holds an external property by
            the name of <emphasis role="bold">prop1</emphasis> it is possible
            declare an object definition in the module context like
            this:</para>

            <programlisting>&lt;objects&gt;

 &lt;object class="com.moduleclasses.MyObjectWithAProperty" id="myObjectWithAProperty"&gt;
  &lt;property name="myProperty" value="<emphasis role="bold">{$prop1}</emphasis>"/&gt;
 &lt;/object&gt;

&lt;/objects&gt;
</programlisting>
          </section>
        </section>

        <section>
          <title>Unloading modules</title>

          <para>Before unloading a module, be sure to invoke the
          <emphasis>dispose()</emphasis> method on any application context
          instance that is associated with it. This will release all the
          resources that the context is holding and will make it, and the
          module, eligible for garbage collection after unloading.</para>

          <section xml:id="disposing_managed_objects">
            <title>Disposing (releasing) container managed objects</title>

            <para>Like the application context, also objects that are managed
            by the context may need to have a disposal method in which they
            are able to release any resources they are holding. There are two
            ways of letting the context know which methods need to be invoked
            on an object once the context itself is being disposed:</para>

            <itemizedlist>
              <listitem>
                <para>The <literal
                xlink:href="asdoc://org.springextensions.actionscript.ioc.IDisposable">IDisposable</literal>
                interface</para>
              </listitem>

              <listitem>
                <para>The destroy-method attribute on an object
                definition</para>
              </listitem>
            </itemizedlist>

            <section xml:id="the_idisposable_interface">
              <title>The IDisposable interface</title>

              <para>The <literal
              xlink:href="asdoc://org.springextensions.actionscript.ioc.IDisposable">IDisposable</literal>
              interface is quite small, its signature look like this and is
              self-explanatory:<programlisting>public interface IDisposable {
 function get isDisposed():Boolean;
 function dispose():void;
}
</programlisting></para>

              <para>If an object is encountered in the context that implements
              this interface its <literal
              xlink:href="asdoc://org.springextensions.actionscript.ioc.IDisposable#dispose()">dispose()</literal>
              method will be invoked once the context itself is being
              disposed.</para>

              <section xml:id="the_destroy_method_attribute">
                <title>The destroy-method attribute</title>

                <para>To avoid any dependencies on framework classes and
                interfaces the destroy (for the <literal
                xlink:href="asdoc://org.springextensions.actionscript.ioc.IDisposable">IDisposable</literal>
                interface this would be its <literal
                xlink:href="asdoc://org.springextensions.actionscript.ioc.IDisposable#dispose()">dispose()</literal>
                method) method for an object can also be defined in its
                associated object definition like this:</para>

                <programlisting>&lt;object class="..." destroy-method="release"/&gt;
</programlisting>
              </section>

              <section>
                <title xml:id="destroying_stage_components">Destroying stage
                components</title>

                <para>The <literal
                xlink:href="asdoc://org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor">DefaultAutowiringStageProcessor</literal>
                will also be invoked after a component is removed from the
                stage. It will check the application context for the existence
                of an object definition for the specified component, and when
                found, see if a destroy method has been defined. If this is
                the case, this method will be invoked.</para>

                <para>If an <literal
                xlink:href="asdoc://org.springextensions.actionscript.ioc.IObjectDefinition">IObjectDefinition</literal>
                wasn't found for the specified component it will check if the
                component perhaps implements the <literal
                xlink:href="asdoc://org.springextensions.actionscript.ioc.IDisposable">IDisposable</literal>
                interface. If so, its <literal
                xlink:href="asdoc://org.springextensions.actionscript.ioc.IDisposable#dispose()">dispose()</literal>
                method will be invoked. See the section '<link
                linkend="the_istagedestroyer_interface">The IStageDestroyer
                interface</link>' to learn more about the underlying
                architecture for this functionality and how to extend
                it.</para>
              </section>
            </section>
          </section>
        </section>

        <section xml:id="instantiation_using_a_constructor">
          <title>Instantiation using a constructor</title>

          <para>When creating an object using the constructor approach, all
          normal classes are usable by and compatible with Spring
          Actionscript. That is, the class being created does not need to
          implement any specific interfaces or be coded in a specific fashion.
          Just specifying the object class should be enough. However,
          depending on what type of <abbrev>IoC</abbrev> you are going to use
          for that specific object, you may need a default (empty)
          constructor.</para>

          <para>When using <abbrev>XML</abbrev>-based configuration metadata
          you can specify your object class like so:</para>

          <programlisting>&lt;object id="exampleObject" class="examples.ExampleObject"/&gt;

&lt;object name="anotherExample" class="examples.ExampleObjectTwo"/&gt;</programlisting>

          <para>The Actionscript equivalent of which would be:</para>

          <programlisting>var exampleObject:ExampleObject;

var anotherExample:ExampleObjectTwo;</programlisting>

          <para>And instantiating one of them by the <abbrev>IoC</abbrev>
          container would look like this:</para>

          <programlisting>var exampleObject:ExampleObject = applicationContext.getObject("exampleObject") as ExampleObject;</programlisting>

          <para>Which in regular Actionscript would look like this:</para>

          <programlisting>var exampleObject:ExampleObject = new ExampleObject();</programlisting>

          <para>The mechanism for supplying arguments to the constructor (if
          required), or setting properties of the object instance after it has
          been constructed, is described shortly.</para>

          <section>
            <title>Object factory events</title>

            <para>The object factory dispatches two events after creating or
            retrieving an object instance from it. Namely <literal
            xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.support.event.ObjectFactoryEvent">ObjectFactoryEvent.OBJECT_CREATED</literal>
            and <literal
            xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.support.event.ObjectFactoryEvent">ObjectFactoryEvent.OBJECT_RETRIEVED</literal>.
            The first is dispatched right after an object instance has been
            instantiated and wored by the object factory, the second right
            before its returned by the <literal
            xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.support.AbstractObjectFactory#getObject()">getObject()</literal>
            method. These events are both dispatched by the object factory and
            through the <literal
            xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>.
            To learn more about the <literal
            xlink:href="asdoc://org.springextensions.actionscript.core.event.EventBus">EventBus</literal>,
            check out the chapter '<link
            linkend="the_eventbus_introduction">The EventBus</link>'.</para>
          </section>
        </section>

        <section xml:id="instantiation_using_a_static_factory_method">
          <title>Instantiation using a static factory method</title>

          <para>When defining an object which is to be created using a static
          factory method, along with the class attribute which specifies the
          class containing the static factory method, another attribute named
          factory-method is needed to specify the name of the factory method
          itself. Spring Actionscript expects to be able to call this method
          and get back a live object, which from that point on is treated as
          if it had been created normally via a constructor. One use for such
          an object definition is to call static factories in legacy code, but
          it can also be used to retrieve objects that have been instantiated
          in <abbrev>MXML</abbrev> and are later pulled into the
          <abbrev>IoC</abbrev> container to be configured.</para>

          <para>The following example shows an object definition which
          specifies that the object is to be created by calling a
          factory-method. Note that the definition does not specify the type
          (class) of the returned object, only the class containing the
          factory method. In this example, the getInstance() method must be a
          static method.</para>

          <programlisting>&lt;object id="exampleObject"
      class="examples.ExampleObjectLocator"
      factory-method="getInstance"/&gt;</programlisting>

          <para>Of which the Actionscript equivalent would be:</para>

          <programlisting>var exampleObject:ExampleObject = ExampleObjectLocator.getInstance();</programlisting>
        </section>

        <section xml:id="instantiation_using_a_factory_method_on_a_different_instance">
          <title>Instantiation using a factory method on a different
          instance</title>

          <para>The previous section explained how to use a static factory
          method on a class, here's how to use a factory method on a different
          instance.</para>

          <programlisting>&lt;object id="exampleFactory"
      class="examples.ExampleObjectFactory"/&gt;

&lt;object id="exampleObject" class="examples.Example"
      factory-object="exampleFactory"
      factory-method="getInstance"/&gt;</programlisting>

          <para>And for this the Actionscript equivalent would be:</para>

          <programlisting>var exampleFactory:ExampleObjectFactory = new ExampleObjectFactory();

var exampleObject:ExampleObject = exampleFactory.getInstance();</programlisting>
        </section>
      </section>

      <section xml:id="composing_mxml_based_configuration_metadata">
        <title>Composing M<abbrev>XML</abbrev>-based configuration
        metadata</title>

        <para>Besides an external or embedded configuration defined in an
        <abbrev>XML</abbrev> file, Spring Actionscript also offers you the
        ability to configure your objects through <abbrev>MXML</abbrev>
        markup. The markup is very similar to the regular <abbrev>XML</abbrev>
        version, but with some slight differences, we will list them
        below.</para>

        <para><abbrev>MXML</abbrev> configuration is done by creating one or
        more <abbrev>MXML</abbrev> files containing objects or object
        definitions and loading them via the <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.MXMLApplicationContext">MXMLApplicationContext</literal>
        class. The difference here with XML configurations is that you can
        either define objects explicitly in MXML (e.g.
        &lt;mx:RemoteObject/&gt;) or implicitly via the &lt;Object/&gt;
        element. The &lt;Object/&gt; element is the same as using the
        &lt;object/&gt; in XML configuration.</para>

        <section xml:id="declaring_the_spring_actionscript_namespace">
          <title>Declaring the Spring Actionscript namespace</title>

          <para>In order to create object definitions in
          <abbrev>MXML</abbrev>, we let Flex know where to find the
          components. We do that by declaring its namespace as follows (in
          MyConfig.mxml for instance):</para>

          <programlisting>&lt;?xml version="1.0"?&gt;
&lt;Objects
 xmlns="http://www.springactionscript.org/mxml/config"
 xmlns:mx="http://www.adobe.com/2006/mxml"&gt;
</programlisting>
        </section>

        <section xml:id="adding_object_definitions">
          <title>Adding object definitions</title>

          <para>Now to add object definitions you add these
          <abbrev>MXML</abbrev> components as children to the
          <abbrev>MXML</abbrev> config.</para>

          <programlisting>&lt;Object id="remoteObject" clazz={mx.rpc.remoting.mxml.RemoteObject}&gt;
 &lt;Property name="destination" value="ColdFusion"/&gt;
 &lt;Property name="concurrency" value="multiple"/&gt;
 &lt;Property name="makeObjectsBindable" value="false"/&gt;
 &lt;Property name="showBusyCursor" value="true"/&gt;
 &lt;Property name="source" value="com.serverside.remote.remoteGateway"/&gt;
&lt;/Object&gt;</programlisting>

          <para>Notice you can define the class of the object with the clazz
          property which is of type Class. This way you will have compile-time
          checking of the classes you include in your application context.
          This is an advantage over regular <abbrev>XML</abbrev> based
          configuration where you need to make sure that all classes are
          included by hand.</para>
        </section>

        <section xml:id="instantiating_the_mxmlapplicationcontext">
          <title>Instantiating the MXMLApplicationContext</title>

          <para>To use this configuration, all we need to do is create an
          instance of the <literal
          xlink:href="asdoc://org.springextensions.actionscript.context.support.MXMLApplicationContext">MXMLApplicationContext</literal>
          class, add the configurations to it and invoke its load method. This
          will (asynchronously) load and initialize the application
          context.</para>

          <para><programlisting>private var appContext:MXMLApplicationContext;

public function applicationCompleteHandler(event:FlexEvent):void {
    appContext = new MXMLApplicationContext();
    appContext.addConfig(MyConfig);
    appContext.addEventListener(Event.COMPLETE, appContext_completeHandler);
    appContext.load();
}</programlisting>Notice that we pass in the class of the configuration file
          and not an instance.</para>
        </section>

        <section xml:id="using_property_placeholders">
          <title>Using property placeholders</title>

          <para>We can also use property placeholders inside objects and
          object definitions defined in <abbrev>MXML</abbrev>. This has the
          advantage that we can load properties defined externally into the
          <abbrev>MXML</abbrev> configuration so we do not need to recompile
          the application when these properties need to be changed. A typical
          example of this is the configuration of service endpoints.</para>

          <para>Below are some examples of property placeholders in
          <abbrev>MXML</abbrev> configuration.</para>

          <para><programlisting>&lt;Objects
 xmlns="http://www.springactionscript.org/mxml/config"
 xmlns:mx="http://www.adobe.com/2006/mxml"
 xmlns:context="org.springextensions.actionscript.ioc.factory.config.*"&gt;

 &lt;mx:Script&gt;
  &lt;![CDATA[
   import mx.rpc.remoting.mxml.RemoteObject;
  ]]&gt;
 &lt;/mx:Script&gt;

 &lt;context:PropertyPlaceholderConfigurer locations="{['properties.properties.txt', 'server.properties.txt']}"/&gt;

 &lt;Object id="string1" clazz="{String}"&gt;
  &lt;ConstructorArg&gt;$(property1)&lt;/ConstructorArg&gt;
 &lt;/Object&gt;

 &lt;mx:Array id="propertiesArray"&gt;
  &lt;mx:String&gt;$(property1)&lt;/mx:String&gt;
  &lt;mx:String&gt;$(property2)&lt;/mx:String&gt;
  &lt;mx:String&gt;$(property3)&lt;/mx:String&gt;
 &lt;/mx:Array&gt;

 &lt;mx:RemoteObject endpoint="http://$(host):$(port)/$(context-root)/messagebroker/amf"/&gt;

 &lt;mx:RemoteObject id="remoteObject1" endpoint="http://$(host):$(port)/$(context-root)/messagebroker/amf"/&gt;

 &lt;mx:RemoteObject id="remoteObject2"&gt;
  &lt;mx:endpoint&gt;http://$(host):$(port)/$(context-root)/messagebroker/amf&lt;/mx:endpoint&gt;
 &lt;/mx:RemoteObject&gt;

 &lt;Object id="remoteObjectDefinitionWithPlaceHolders" clazz="{RemoteObject}"&gt;
  &lt;Property name="endpoint" value="http://$(host):$(port)/$(context-root)/messagebroker/amf"/&gt;
 &lt;/Object&gt;

&lt;/Objects&gt;</programlisting></para>
        </section>
      </section>

      <section xml:id="using_the_container">
        <title>Using the container</title>

        <para>An <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>
        (or <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>)
        is essentially nothing more than the interface for an advanced factory
        capable of maintaining a registry of different objects and their
        dependencies. The <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>,
        which is also an implementation of the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory">IObjectFactory</literal>
        interface, enables you to read object definitions and access them
        using the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory#getObject()">getObject</literal>()
        method. When using just the XMLApplicationContext you would create one
        and read in some object definitions in the <abbrev>XML</abbrev> format
        as follows:</para>

        <programlisting>var applicationContext:<literal
            xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal> = new <literal
            xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>();
applicationContext.addConfigLocation("application-context.xml");
applicationContext.addEventListener(Event.COMPLETE, handleComplete);
applicationContext.load();</programlisting>

        <para>And in the handleComplete method (or any other code which runs
        after this event has fired) you access your object like this:</para>

        <programlisting>public function handleComplete(event:FlexEvent):void {

    var exampleObject:ExampleObject = applicationContext.<literal
            xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory#getObject()">getObject</literal>("exampleObject") as ExampleObject;
}</programlisting>

        <para>Basically that is all there is to it. Using <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory#getObject()">getObject</literal>(String)
        you can retrieve instances of your object; the client-side view of the
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>
        is simple. The <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>
        object has just a few other methods, but ideally your application code
        should never use them... Ideally, your application code should have no
        calls to the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory#getObject()">getObject</literal>(String)
        method at all, and thus no dependency on Spring Actionscript APIs at
        all.</para>
      </section>
    </section>

    <section xml:id="dependencies">
      <title>Dependencies</title>

      <para>Your typical enterprise application is not made up of a single
      object. Even the simplest of applications will no doubt have at least a
      handful of objects that work together to present what the end-user sees
      as a coherent application. This next section explains how you go from
      defining a number of object definitions that stand-alone, each to
      themselves, to a fully realized application where objects work (or
      collaborate) together to achieve some goal (usually an application that
      does what the end-user wants).</para>

      <section xml:id="injecting_dependencies">
        <title>Injecting dependencies</title>

        <para>The basic principle behind Dependency Injection
        (<abbrev>DI</abbrev>) is that objects define their dependencies (that
        is to say the other objects they work with) only through constructor
        arguments, arguments to a factory method, or properties which are set
        on the object instance after it has been constructed or returned from
        a factory method. Then, it is the job of the container to actually
        inject those dependencies when it creates the object. This is
        fundamentally the inverse, hence the name Inversion of Control
        (<abbrev>IoC</abbrev>), of the object itself being in control of
        instantiating or locating its dependencies on its own using direct
        construction of classes, or something like the Service Locator
        pattern.</para>

        <para>It becomes evident upon usage that code gets much cleaner when
        the <abbrev>DI</abbrev> principle is applied, and reaching a higher
        grade of decoupling is much easier when objects do not look up their
        dependencies, but are provided with them (and additionally do not even
        know where the dependencies are located and of what concrete class
        they are). <abbrev>DI</abbrev> exists in two major variants, namely
        <literal xlink:href="constructor_injection">Constructor
        Injection</literal> and <literal xlink:href="setter_injection">Setter
        Injection</literal>.</para>

        <section xml:id="constructor_injection">
          <title>Constructor Injection</title>

          <para>Constructor-based <abbrev>DI</abbrev> is effected by invoking
          a constructor with a number of arguments, each representing a
          dependency. Find below an example of a class that could only be
          dependency injected using constructor injection. Notice that there
          is nothing special about this class.</para>

          <programlisting>public class <classname>SimpleMovieLister</classname> {

    <lineannotation>// the SimpleMovieLister has a dependency on a MovieFinder</lineannotation>
    private _movieFinder:MovieFinder;

    <lineannotation>// a constructor so that the Spring Actionscript container can 'inject' a MovieFinder</lineannotation>
    public SimpleMovieLister(movieFinder:MovieFinder) {
        _movieFinder = movieFinder;
    }
    
    <lineannotation>// business logic that actually 'uses' the injected MovieFinder is omitted...</lineannotation>
}</programlisting>
        </section>

        <section xml:id="setter_injection">
          <title>Setter Injection</title>

          <para>Setter-based <abbrev>DI</abbrev> is realized by calling setter
          methods or plainly setting properties on your objects after invoking
          a no-argument constructor or no-argument static factory method to
          instantiate your object. Find below an example of a class that can
          only be dependency injected using pure setter injection. Note that
          there is nothing special about this class... it is plain old
          Actionscript.</para>

          <programlisting>public class <classname>SimpleMovieLister</classname> {

    <lineannotation>// the SimpleMovieLister has a dependency on the MovieFinder</lineannotation>
    private _movieFinder:MovieFinder;

    <lineannotation>// a setter method so that the Spring container can 'inject' a MovieFinder</lineannotation>
    public function set movieFinder(value:MovieFinder):void {
        if (value !== this._movieFinder){
            this._movieFinder = movieFinder;
        }
    }

    <lineannotation>// business logic that actually 'uses' the injected MovieFinder is omitted...</lineannotation>
}</programlisting>

          <para>The <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.XMLObjectFactory">XMLObjectFactory</literal>
          supports both of these variants for injecting dependencies into
          objects it manages. (It in fact also supports injecting setter-based
          dependencies after some dependencies have already been supplied via
          the constructor approach.) The configuration for the dependencies
          comes in the form of an <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.ObjectDefinition">ObjectDefinition</literal>,
          which is used together with <literal
          xlink:href="asdoc://org.springextensions.actionscript.objects.IPropertyEditor">IPropertyEditor</literal>
          implementations to know how to convert properties from one format to
          another. However, most users of Spring Actionscript will not be
          dealing with these classes directly (that is programmatically), but
          rather with an <abbrev>XML</abbrev> definition file which will be
          converted internally into instances of these classes, and used to
          load an entire Spring <abbrev>IoC</abbrev> container
          instance.</para>

          <para>Object dependency resolution generally happens as
          follows:</para>

          <itemizedlist>
            <listitem>
              <para>The <literal
              xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.XMLObjectFactory">XMLObjectFactory</literal>
              is created and initialized with a configuration which describes
              all the objects. (Most Spring Actionscript users use an
              ApplicationContext implementation that supports
              <abbrev>XML</abbrev> format configuration files.)</para>
            </listitem>

            <listitem>
              <para>Each object has dependencies expressed in the form of
              properties, constructor arguments, or arguments to the
              static-factory method when that is used instead of a normal
              constructor. These dependencies will be provided to the object,
              when the object is actually created.</para>
            </listitem>

            <listitem>
              <para>Each property or constructor argument is either an actual
              definition of the value to set, or a reference to another object
              in the container.</para>
            </listitem>

            <listitem>
              <para>Each property or constructor argument which is a value
              must be able to be converted from whatever format it was
              specified in, to the actual type of that property or constructor
              argument. By default Spring can convert a value supplied in
              string format to all built-in types, such as int, uint, String,
              Boolean, etc.</para>
            </listitem>
          </itemizedlist>

          <para>The Spring Actionscript container validates the configuration
          of each object as the container is created, including the validation
          that properties which are object references are actually referring
          to valid objects. However, the object properties themselves are not
          set until the object is actually created. For those objects that are
          singleton-scoped and set to be pre-instantiated (such as singleton
          objects in an ApplicationContext), creation happens at the time that
          the container is created, but otherwise this is only when the object
          is requested. When an object actually has to be created, this will
          potentially cause a graph of other objects to be created, as its
          dependencies and its dependencies' dependencies (and so on) are
          created and assigned.</para>

          <para>You can generally trust Spring Actionscript to do the right
          thing. It will detect misconfiguration issues, such as references to
          non-existent objects and circular dependencies, at container
          load-time. It will actually set properties and resolve dependencies
          as late as possible, which is when the object is actually created.
          This means that a Spring Actionscript container which has loaded
          correctly can later generate an exception when you request an object
          if there is a problem creating that object or one of its
          dependencies. This could happen if the object throws an exception as
          a result of a missing or invalid property, for example. This
          potentially delayed visibility of some configuration issues is why
          ApplicationContext implementations by default pre-instantiate
          singleton objects. At the cost of some upfront time and memory to
          create these objects before they are actually needed, you find out
          about configuration issues when the ApplicationContext is created,
          not later. If you wish, you can still override this default behavior
          and set any of these singleton objects to lazy-initialize (that is
          not be pre-instantiated).</para>

          <para>If no circular dependencies are involved (see sidebar for a
          discussion of circular dependencies), when one or more collaborating
          objects are being injected into a dependent object, each
          collaborating object is totally configured prior to being passed
          (via one of the <abbrev>DI</abbrev> flavors) to the dependent
          object. This means that if object A has a dependency on object B,
          the Spring Actionscript <abbrev>IoC</abbrev> container will totally
          configure object B prior to invoking the setter method on object A;
          you can read 'totally configure' to mean that the object will be
          instantiated (if not a pre-instantiated singleton), all of its
          dependencies will be set, and the relevant lifecycle methods (such
          as a configured init method) will all be invoked.</para>
        </section>

        <section xml:id="method_invocations">
          <title>Method invocations</title>

          <para>To invoke one or more methods after the object has been
          constructed by the container add <emphasis
          role="bold">&lt;method-invocation/&gt;</emphasis> elements to the
          <emphasis role="bold">&lt;object/&gt;</emphasis>
          element.<programlisting>&lt;object id="exampleObject" class="examples.ExampleObject"&gt;
  &lt;method-invocation name="someMethod"/&gt;
&lt;/object&gt;
</programlisting></para>

          <para>If the method in question needs any kind of arguments, add
          them like this:</para>

          <programlisting>&lt;object id="exampleObject" class="examples.ExampleObject"&gt;
  &lt;method-invocation name="someMethod"&gt;
    &lt;arg value="${externalPropertyName}"/&gt; <lineannotation>//External property value</lineannotation>
    &lt;arg ref="anotherExampleObject"/&gt;      <lineannotation>//Another object instance managed by the container</lineannotation>
    &lt;arg&gt;                                  <lineannotation>//Another object instance defined inline</lineannotation>
      &lt;object class="..."/&gt;
    &lt;/arg&gt;
  &lt;/method-invocation&gt;
&lt;/object&gt;

&lt;object id="<emphasis role="bold">anotherExampleObject</emphasis>" class="examples.AnotherObject"/&gt;
</programlisting>
        </section>

        <section xml:id="some_samples">
          <title>Some examples</title>

          <para>First, an example of using <abbrev>XML</abbrev>-based
          configuration metadata for setter-based <abbrev>DI</abbrev>. Find
          below a small part of a Spring Actionscript <abbrev>XML</abbrev>
          configuration file specifying some object definitions.</para>

          <programlisting>&lt;object id="exampleObject" class="examples.ExampleObject"&gt;

  <lineannotation>&lt;!-- setter injection using the nested &lt;ref/&gt; element --&gt;</lineannotation>
  &lt;property name="objectOne"&gt;&lt;ref&gt;<emphasis role="bold">anotherExampleObject</emphasis>&lt;/ref&gt;&lt;/property&gt;

  <lineannotation>&lt;!-- setter injection using the neater 'ref' attribute --&gt;</lineannotation>
  &lt;property name="objectTwo" ref="<emphasis role="bold">yetAnotherObject</emphasis>"/&gt;

  &lt;property name="integerProperty" value="1"/&gt;

  &lt;property name="booleanProperty" value="true"/&gt;
&lt;/object&gt;

&lt;object id="<emphasis role="bold">anotherExampleObject</emphasis>" class="examples.AnotherObject"/&gt;

&lt;object id="<emphasis role="bold">yetAnotherObject</emphasis>" class="examples.YetAnotherObject"/&gt;</programlisting>

          <programlisting>public class <classname>ExampleObject</classname> {

    private var _objectOne:AnotherObject;
    private var _objectTwo:YetAnotherObject;
    private var _i:int;
    private var _bool:Boolean;

    public function set objectOne(value:AnotherObject):void {
        if (value !== _objectOne){
            _objectOne = value;
        }
    }

    public function set objectTwo(value:YetAnotherObject):void {
        if (value !== _objectTwo)
            _objectTwo = value;
        }
    }

    public function set integerProperty(value:int):void {
        if (value != _i){
             _i = value;
        }
    }    

    public function set booleanProperty(value:Boolean):void {
        if (value != _bool){
             _bool = value;
        }
    }    
}</programlisting>

          <para>As you can see, setters have been declared to match against
          the properties specified in the <abbrev>XML</abbrev> file. Find
          below an example of using constructor-based
          <abbrev>DI</abbrev>.</para>

          <programlisting>&lt;object id="exampleObject" class="examples.ExampleObject"&gt;

  <lineannotation>&lt;!-- constructor injection using the nested &lt;ref/&gt; element --&gt;</lineannotation>
  &lt;constructor-arg&gt;
    &lt;ref&gt;<emphasis role="bold">anotherExampleObject</emphasis>&lt;/ref&gt;
  &lt;/constructor-arg&gt;
  
  <lineannotation>&lt;!-- constructor injection using the neater 'ref' attribute --&gt;</lineannotation>
  &lt;constructor-arg ref="<emphasis role="bold">yetAnotherObject</emphasis>"/&gt;
  
  &lt;constructor-arg value="1"/&gt;

  &lt;constructor-arg value="true"/&gt;
&lt;/object&gt;

&lt;object id="<emphasis role="bold">anotherExampleObject</emphasis>" class="examples.AnotherObject"/&gt;
&lt;object id="<emphasis role="bold">yetAnotherObject</emphasis>" class="examples.YetAnotherObject"/&gt;</programlisting>

          <programlisting>public class <classname>ExampleObject</classname> {

    private var _objectOne:AnotherObject;
    private var _objectTwo:YetAnotherObject;
    private var _i:int;
    private var _bool:Boolean;
    
    public ExampleObject(anotherObject:AnotherObject, yetAnotherObject:YetAnotherObject, i:int, b:Boolean) {
        _objectOne = anotherobject;
        _objectTwo = yetAnotherobject;
        _i = i;
        _bool = b;
    }
}</programlisting>

          <para>Notice, the constructor arguments specified in the object
          definition will be used to pass in as arguments to the constructor
          of the ExampleObject. Now consider a variant of this where instead
          of using a constructor, Spring Actionscript is told to call a static
          factory method to return an instance of the object:</para>

          <programlisting>&lt;object id="exampleObject" class="examples.ExampleObjectFactory" factory-method="createInstance"&gt;
  &lt;constructor-arg ref="<emphasis role="bold">anotherExampleObject</emphasis>"/&gt;
  &lt;constructor-arg ref="<emphasis role="bold">yetAnotherObject</emphasis>"/&gt;
  &lt;constructor-arg value="1"/&gt; 
&lt;/object&gt;

&lt;object id="<emphasis role="bold">anotherExampleObject</emphasis>" class="examples.AnotherObject"/&gt;
&lt;object id="<emphasis role="bold">yetAnotherObject</emphasis>" class="examples.YetAnotherObject"/&gt;</programlisting>

          <programlisting>public final class <classname>ExampleObjectFactory</classname> {

    <lineannotation>// a static factory method; the arguments to this method can be
    // considered the dependencies of the object that is returned,
    // regardless of how those arguments are actually used.</lineannotation>
    public static createInstance(anotherObject:AnotherObject, yetAnotherObject:YetAnotherObject, i:int):ExampleObject {

        var eb:ExampleObject = new ExampleObject(...);
        // some other operations...
        return eb;
    }
}</programlisting>

          <para>Note that arguments to the static factory method are supplied
          via <emphasis role="bold"><literal
          xlink:href="dtd://anchor_constructor-argType">&lt;constructor-arg/&gt;</literal></emphasis>
          elements, exactly the same as if a constructor had actually been
          used. Also, it is important to realize that the type of the class
          being returned by the factory method does not have to be of the same
          type as the class which contains the static factory method.</para>
        </section>
      </section>

      <section xml:id="dependencies_and_configuration_in_detail">
        <title>Dependencies and configuration in detail</title>

        <para>As mentioned in the previous section, object properties and
        constructor arguments can be defined as either references to other
        managed objects (collaborators), or values defined inline. Spring
        Actionscript's <abbrev>XML</abbrev>-based configuration metadata
        supports a number of sub-element types within its <emphasis
        role="bold"><literal
        xlink:href="dtd://anchor_propertyType">&lt;property/&gt;</literal></emphasis>
        and <emphasis role="bold"><literal
        xlink:href="dtd://anchor_constructor-argType">&lt;constructor-arg/&gt;</literal></emphasis>
        elements for just this purpose.</para>
      </section>

      <section xml:id="straight_values_etc">
        <title>Straight values (primitives, Strings, etc.)</title>

        <para>The <emphasis role="bold"><literal wordsize=""
        xlink:href="dtd://anchor_valueType">&lt;value/&gt;</literal></emphasis>
        element specifies a property or constructor argument as a
        human-readable string representation. As mentioned previously,
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.objects.IPropertyEditor">IPropertyEditor</literal>
        implementations are used to convert these string values from a String
        to the actual type of the property or argument.</para>

        <programlisting>&lt;object id="amfChannel" class="mx.messaging.channels.AMFChannel"&gt;
  &lt;constructor-arg&gt;
    &lt;value&gt;my-amf&lt;/value&gt;
  &lt;/constructor-arg&gt;
  &lt;constructor-arg&gt;
    &lt;value&gt;http://{server.name}:{server.port}/flex2gateway/&lt;/value&gt;
  &lt;/constructor-arg&gt;
  &lt;property name="pollingEnabled"&gt;
    &lt;value&gt;false&lt;/value&gt;
  &lt;/property&gt;
&lt;/object&gt;</programlisting>

        <para>The <emphasis role="bold"><literal
        xlink:href="dtd://anchor_propertyType">&lt;property/&gt;</literal></emphasis>
        and <emphasis role="bold"><literal
        xlink:href="dtd://anchor_constructor-argType">&lt;constructor-arg/&gt;</literal></emphasis>
        elements also support the use of the 'value' attribute, which can lead
        to much more succinct configuration. When using the 'value' attribute,
        the above object definition reads like so:</para>

        <programlisting>&lt;object id="amfChannel" class="mx.messaging.channels.AMFChannel"&gt;
  &lt;constructor-arg value="my-amf"/&gt;
  &lt;constructor-arg value="http://{server.name}:{server.port}/flex2gateway/"/&gt;
  &lt;property name="pollingEnabled" value="false"/&gt;
&lt;/object&gt;</programlisting>
      </section>

      <section xml:id="references_to_other_objects">
        <title>References to other objects (collaborators)</title>

        <para>The ref element is the final element allowed inside a <emphasis
        role="bold"><literal
        xlink:href="dtd://anchor_constructor-argType">&lt;constructor-arg/&gt;</literal></emphasis>
        or <emphasis role="bold"><literal
        xlink:href="dtd://anchor_propertyType">&lt;property/&gt;</literal></emphasis>
        definition element. It is used to set the value of the specified
        property to be a reference to another object managed by the container
        (a collaborator). As mentioned in a previous section, the referred-to
        object is considered to be a dependency of the object who's property
        is being set, and will be initialized on demand as needed (if it is a
        singleton object it may have already been initialized by the
        container) before the property is set. All references are ultimately
        just a reference to another object.</para>

        <para>Specifying the target object by using the <emphasis
        role="bold"><literal
        xlink:href="dtd://anchor_refType">&lt;ref/&gt;</literal></emphasis>
        tag is the most general form.</para>

        <programlisting>&lt;ref&gt;myTargetObject&lt;/ref&gt;</programlisting>
      </section>

      <section xml:id="inner_objects">
        <title>Inner objects</title>

        <para>An <emphasis role="bold"><literal
        xlink:href="dtd://anchor_objectType">&lt;object/&gt;</literal></emphasis>
        element inside the <emphasis role="bold"><literal
        xlink:href="dtd://anchor_propertyType">&lt;property/&gt;</literal></emphasis>
        or <emphasis role="bold"><literal
        xlink:href="dtd://anchor_constructor-argType">&lt;constructor-arg/&gt;</literal></emphasis>
        elements is used to define a so-called inner object. An inner object
        definition does not need to have any id defined, and it is best not to
        even specify any id value because the id value simply will be ignored
        by the container.</para>

        <programlisting>&lt;object id="outer" class="..."&gt;
  <lineannotation>&lt;!-- instead of using a reference to a target object, simply define the target object inline --&gt;</lineannotation>
  &lt;property name="target"&gt;
    &lt;object class="com.example.Person"&gt; <lineannotation>&lt;!-- this is the inner object --&gt;</lineannotation>
      &lt;property name="name" value="Fiona Apple"/&gt;
      &lt;property name="age" value="25"/&gt;
    &lt;/object&gt;
  &lt;/property&gt;
&lt;/object&gt;</programlisting>

        <para>Note that in the specific case of inner objects, the 'scope'
        flag and any 'id' attribute are effectively ignored. Inner objects are
        always anonymous and they are always scoped as prototypes.
        <emphasis>Please also note that it is not possible to inject inner
        objects into collaborating objects other than the enclosing
        object.</emphasis></para>
      </section>

      <section xml:id="collections">
        <title>Collections</title>

        <para>The <emphasis role="bold"><literal xlink:arcrole=""
        xlink:href="dtd://anchor_arrayType">&lt;array/&gt;</literal></emphasis>,
        <emphasis role="bold"><literal
        xlink:href="dtd://anchor_arrayCollectionType">&lt;array-collection/&gt;</literal></emphasis>
        , <emphasis role="bold"><literal
        xlink:href="dtd://anchor_dictionaryType">&lt;dictionary/&gt;</literal></emphasis>
        and <emphasis
        role="bold"><literal>&lt;vector/&gt;</literal></emphasis> elements
        allow properties and arguments of the Actionscript collection type
        Array, ArrayCollection, Dictionary and Vector, respectively, to be
        defined and set.</para>

        <para>Be aware that the array-collection type can only be used in a
        Flex based application (using the <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>)
        object since it is part of the framework.</para>

        <para>Also be careful only to use the Vector type in applications that
        are made for Flash player version 10 or higher.</para>

        <programlisting>&lt;object id="moreComplexObject" class="example.ComplexObject"&gt;
  &lt;property name="adminEmails"&gt;
    &lt;dictionary&gt;
        &lt;entry key="administrator" value="administrator@example.org"/&gt;
        &lt;entry key="support" value="support@example.org"/&gt;
        <lineannotation>&lt;!-- or a more verbose way of defining an entry --&gt;</lineannotation>
        &lt;entry&gt;
          &lt;key&gt;development&lt;/key&gt;
          &lt;value&gt;development@example.org&lt;/value&gt;
        &lt;/entry&gt;
    &lt;/dictionary&gt;
  &lt;/property&gt;

  &lt;property name="someList"&gt;
    &lt;array&gt;
        &lt;value&gt;a list element followed by a reference&lt;/value&gt;
        &lt;value&gt;&lt;ref object="myOtherObject" /&gt;&lt;/value&gt;
    &lt;/array&gt;
  &lt;/property&gt;

  <lineannotation>&lt;!-- Only use this in a Flex based application --&gt;</lineannotation>
  &lt;property name="someOtherList"&gt;
    &lt;array-collection&gt;
        &lt;value&gt;a list element followed by a reference&lt;/value&gt;
        &lt;value&gt;&lt;ref object="myOtherObject" /&gt;&lt;/value&gt;
    &lt;/array-collection&gt;
  &lt;/property&gt;

  <lineannotation>&lt;!-- Only use this in an application made for Flash player 10 and higher --&gt;
</lineannotation>  &lt;property name="vectorProperty"&gt;
    &lt;vector type="String"&gt;
      &lt;value&gt;string1&lt;/value&gt;
      &lt;value&gt;string2&lt;/value&gt;
      &lt;value&gt;string3&lt;/value&gt;
      &lt;value&gt;string4&lt;/value&gt;
    &lt;/vector&gt;
  &lt;/property&gt;

&lt;/object&gt;</programlisting>

        <note>
          <para>The nested element style used this initial example tends to
          become quite verbose. Fortunately, there are attribute shortcuts for
          most elements, which you can read about in <link
          linkend="shortcuts_and_convenience_options">Shortcuts and other
          convenience options for XML-based configuration
          metadata</link>.</para>
        </note>
      </section>

      <section xml:id="injecting_the_application_context_using_the_this_reference">
        <title>Injecting the application context using the 'this'
        reference</title>

        <para>Injecting the application context can be achieved by using the
        id 'this' as reference:</para>

        <programlisting>&lt;method-invocation name="someMethod"&gt;
  &lt;arg ref="<emphasis role="bold">this</emphasis>"/&gt;
&lt;/method-invocation&gt;</programlisting>

        <para>This works for property chains on the application context as
        well, for example:</para>

        <programlisting>&lt;method-invocation name="someMethod"&gt;
  &lt;arg ref="<emphasis role="bold"><emphasis role="bold">this</emphasis>.applicationDomain</emphasis>"/&gt;
&lt;/method-invocation&gt;</programlisting>
      </section>

      <section xml:id="shortcuts_and_convenience_options">
        <title>Shortcuts and other convenience options for
        <abbrev>XML</abbrev>-based configuration metadata</title>

        <para>The configuration metadata shown so far is a tad verbose. That
        is why there are several options available for you to limit the amount
        of <abbrev>XML</abbrev> you have to write to configure your
        components. The first is a shortcut to define values and references to
        other objects as part of a <emphasis role="bold"
        xlink:href="dtd://anchor_propertyType">&lt;property/&gt;</emphasis>
        definition. The second is slightly different format of specifying
        properties altogether.</para>

        <section xml:id="xml_based_configuration_metadata_shortcuts">
          <title><abbrev>XML</abbrev>-based configuration metadata
          shortcuts</title>

          <para>The <emphasis role="bold"><literal
          xlink:href="dtd://anchor_propertyType">&lt;property/&gt;</literal></emphasis>,
          <emphasis role="bold"><literal
          xlink:href="dtd://anchor_constructor-argType">&lt;constructor-arg/&gt;</literal></emphasis>,
          and <emphasis role="bold"><literal
          xlink:href="dtd://anchor_entryType">&lt;entry/&gt;</literal></emphasis>
          elements all support a 'value' attribute which may be used instead
          of embedding a full <emphasis role="bold"><literal
          xlink:href="dtd://anchor_valueType">&lt;value/&gt;</literal></emphasis>
          element. Therefore, the following:</para>

          <programlisting>&lt;property name="myProperty"&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/property&gt;</programlisting>

          <programlisting>&lt;constructor-arg&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/constructor-arg&gt;</programlisting>

          <programlisting>&lt;entry key="myKey"&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/entry&gt;</programlisting>

          <para>are equivalent to:</para>

          <programlisting>&lt;property name="myProperty" value="hello"/&gt;</programlisting>

          <programlisting>&lt;constructor-arg value="hello"/&gt;</programlisting>

          <programlisting>&lt;entry key="myKey" value="hello"/&gt;</programlisting>
        </section>
      </section>

      <section xml:id="using_depends_on">
        <title>Using depends-on</title>

        <para>For most situations, the fact that an object is a dependency of
        another is expressed by the fact that one object is set as a property
        of another. This is typically accomplished with the <emphasis
        role="bold"><literal
        xlink:href="dtd://anchor_refType">&lt;ref/&gt;</literal></emphasis>
        element in <abbrev>XML</abbrev>-based configuration metadata. For the
        relatively infrequent situations where dependencies between objects
        are less direct, the 'depends-on' attribute may be used to explicitly
        force one or more objects to be initialized before the object using
        this element is initialized. Find below an example of using the
        'depends-on' attribute to express a dependency on a single
        object.</para>

        <programlisting>&lt;object id="objectOne" class="ExampleObject" depends-on="manager"/&gt;

&lt;object id="manager" class="ManagerObject" /&gt;</programlisting>

        <para>If you need to express a dependency on multiple objects, you can
        supply a list of object names as the value of the 'depends-on'
        attribute, with commas, whitespace and semicolons all valid
        delimiters, like so:</para>

        <programlisting>&lt;object id="objectOne" class="ExampleObject" depends-on="<emphasis
            role="bold">manager</emphasis>,<emphasis role="bold">accountDao</emphasis>"&gt;
  &lt;property name="manager" ref="<emphasis role="bold">manager</emphasis>" /&gt;
&lt;/object&gt;

&lt;object id="<emphasis role="bold">manager</emphasis>" class="ManagerObject" /&gt;
&lt;object id="<emphasis role="bold">accountDao</emphasis>" class="x.y.as.AccountDao" /&gt;</programlisting>
      </section>

      <section xml:id="ensuring_dependency_injection_with_dependency_check">
        <title>Ensuring dependency injection with dependency check</title>

        <para>Spring Actionscript has 4 different validation modes to check if
        properties have been on an object. The different dependency check
        modes are '<emphasis role="bold">none</emphasis>', '<emphasis
        role="bold">simple</emphasis>', '<emphasis
        role="bold">object</emphasis>', and '<emphasis
        role="bold">all</emphasis>'. The default mode is '<emphasis
        role="bold">none</emphasis>', so there isn't any dependency check
        validation unless explicitly configured. All values being checked must
        have been set in the configuration file or by autowiring. If a class
        has any defaults or fields that don't need to be set, the dependency
        check modes won't be of any use.</para>

        <table audience="" border="1" style="">
          <caption>Autowiring modes</caption>

          <thead>
            <tr>
              <th>Mode</th>

              <th>Explanation</th>
            </tr>
          </thead>

          <tr>
            <td>none</td>

            <td>No dependency checking. This is the default.</td>
          </tr>

          <tr>
            <td>simple</td>

            <td>Dependency check for primitives and collections.</td>
          </tr>

          <tr>
            <td>object</td>

            <td>Dependency check for objects (collaborators).</td>
          </tr>

          <tr>
            <td>all</td>

            <td>Dependency check for primitives, collections, and objects
            (collaborators).</td>
          </tr>
        </table>

        <para>The '<emphasis role="bold">simple</emphasis>' mode checks that
        all primitive and collection values have been set. The '<emphasis
        role="bold">object</emphasis>' mode checks that all collaborators
        (objects) have been set. The '<emphasis role="bold">all</emphasis>'
        mode checks for everything that the '<emphasis
        role="bold">simple</emphasis>' and '<emphasis
        role="bold">object</emphasis>' modes do.</para>
      </section>

      <section xml:id="lazilyinstantiated_beans">
        <title>Lazily-instantiated objects</title>

        <para>The default behavior for <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContext">IApplicationContext</literal>
        implementations is to eagerly pre-instantiate all singleton objects at
        startup. Pre-instantiation means that an <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContext">IApplicationContext</literal>
        will eagerly <emphasis>create and configure</emphasis> all of its
        singleton objects as part of its initialization process. Generally
        this is a good thing, because it means that any errors in the
        configuration or in the surrounding environment will be discovered
        immediately (as opposed to possibly hours down the line).</para>

        <para>However, there are times when this behavior is not what is
        desired. If you do not want a singleton object to be pre-instantiated
        when using an <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContext">IApplicationContext</literal>,
        you can selectively control this by marking an object definition as
        lazily-initialized. A lazily-initialized object indicates to the
        <abbrev>IoC</abbrev> container whether or not an object instance
        should be created at startup or when it is first requested.</para>

        <para>When configuring objects via <abbrev>XML</abbrev>, this lazy
        loading is controlled by the 'lazy-init' attribute on the <emphasis
        role="bold"><literal
        xlink:href="dtd://anchor_objectType">&lt;object/&gt;</literal></emphasis>
        element; for example:</para>

        <programlisting>&lt;object id="lazy" class="com.foo.ExpensiveToCreateObject" <emphasis
            role="bold">lazy-init="true"</emphasis>/&gt;

&lt;object name="not.lazy" class="com.foo.AnotherObject"/&gt;</programlisting>

        <para>When the above configuration is consumed by an <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContext">IApplicationContext</literal>,
        the object named 'lazy' will not be eagerly pre-instantiated when the
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContext">IApplicationContext</literal>
        is starting up, whereas the 'not.lazy' object will be eagerly
        pre-instantiated.</para>

        <para>One thing to understand about lazy-initialization is that even
        though an object definition may be marked up as being
        lazy-initialized, if the lazy-initialized object is the dependency of
        a singleton object that is not lazy-initialized, when the <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContext">IApplicationContext</literal>
        is eagerly pre-instantiating the singleton, it will have to satisfy
        all of the singletons dependencies, one of which will be the
        lazy-initialized object! So don't be confused if the
        <abbrev>IoC</abbrev> container creates one of the objects that you
        have explicitly configured as lazy-initialized at startup;
        <emphasis>all that means is that the lazy-initialized object is being
        injected into a non-lazy-initialized singleton object
        elsewhere</emphasis>.</para>
      </section>

      <section xml:id="a_graphical_overview_of_the_getobject_flow">
        <title>A graphical overview of the getObject() flow</title>

        <para>See below for a graphical overview of the program flow that
        happens after you call the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.support.AbstractObjectFactory#getObject()">getObject()</literal>
        method on an application context instance.</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="images/getobjectflow.png" format="PNG"></imagedata>
            </imageobject>
          </inlinemediaobject></para>
      </section>

      <section xml:id="a_graphical_overview_of_the_wiring_flow_of_an_object">
        <title>A graphical overview of the wiring flow of an object</title>

        <para>See below for a graphical overview of the program flow that
        happens when an object is being wired by the application
        context.</para>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="images/objectwiringflow.png" format="PNG"></imagedata>
            </imageobject>
          </inlinemediaobject></para>
      </section>

      <section xml:id="autowiring_objects">
        <title>Autowiring collaborators</title>

        <para>The Spring Actionscript container is able to autowire
        relationships between collaborating objects. This means that it is
        possible to automatically let Spring Actionscript resolve
        collaborators (other objects) for your object by inspecting the
        contents of the ObjectDefinition. The autowiring functionality has
        five modes. Autowiring is specified per object and can thus be enabled
        for some objects, while other objects will not be autowired. Using
        autowiring, it is possible to reduce or eliminate the need to specify
        properties or constructor arguments, thus saving a significant amount
        of typing. When using <abbrev>XML</abbrev>-based configuration
        metadata, the autowire mode for a object definition is specified by
        using the autowire attribute of the <emphasis role="bold"><literal
        xlink:href="dtd://anchor_objectType">&lt;object/&gt;</literal></emphasis>
        element. The following values are allowed:</para>

        <table audience="" border="1" style="">
          <caption>Autowiring modes</caption>

          <thead>
            <tr>
              <th>Mode</th>

              <th>Explanation</th>
            </tr>
          </thead>

          <tr>
            <td>no</td>

            <td>No autowiring at all. Object references must be defined via a
            <literal>ref</literal> element. This is the default, and changing
            this is discouraged for larger deployments, since explicitly
            specifying collaborators gives greater control and clarity. To
            some extent, it is a form of documentation about the structure of
            a system.</td>
          </tr>

          <tr>
            <td>byName</td>

            <td>Autowiring by property name. This option will inspect the
            container and look for an object named exactly the same as the
            property which needs to be autowired. For example, if you have an
            object definition which is set to autowire by name, and it
            contains a <emphasis>master</emphasis> property, Spring
            Actionscript will look for an object definition named
            <literal>master</literal>, and use it to set the property.</td>
          </tr>

          <tr>
            <td>byType</td>

            <td>Allows a property to be autowired if there is exactly one
            object of the property type in the container. If there is more
            than one, a fatal exception is thrown, and this indicates that you
            may not use <emphasis>byType</emphasis> autowiring for that
            object. If there are no matching objects, nothing happens; the
            property is not set.</td>
          </tr>

          <tr>
            <td>constructor</td>

            <td>This is analogous to <emphasis>byType</emphasis>, but applies
            to constructor arguments. If there isn't exactly one object of the
            constructor argument type in the container, a fatal error is
            raised.</td>
          </tr>

          <tr>
            <td>autodetect</td>

            <td>Chooses constructor or <emphasis>byType</emphasis> through
            introspection of the object class. If a default (parameterless)
            constructor is found, the byType mode will be applied.</td>
          </tr>
        </table>

        <para>Note that explicit dependencies in <emphasis role="bold"
        xlink:href="dtd://anchor_propertyType">&lt;property/&gt;</emphasis>
        and <emphasis role="bold"
        xlink:href="dtd://anchor_constructor-argType">&lt;constructor-arg/&gt;</emphasis>
        settings always override autowiring. Please also note that it is not
        currently possible to autowire so-called <emphasis>simple</emphasis>
        properties such as primitives, <literal>Strings</literal>, and
        <literal>Classes</literal> (and arrays of such simple properties).
        (This is by-design and should be considered a
        <emphasis>feature</emphasis>.) When using either the
        <emphasis>byType</emphasis> or <emphasis>constructor</emphasis>
        autowiring mode, it is possible to wire arrays. In such cases all
        autowire candidates within the container that match the expected type
        will be provided to satisfy the dependency.</para>

        <para>It is important to understand the various advantages and
        disadvantages of autowiring. Some advantages of autowiring
        include:</para>

        <itemizedlist>
          <listitem>
            <para>Autowiring can significantly reduce the volume of
            configuration required. However, mechanisms such as the use of a
            object template (discussed elsewhere in this chapter) are also
            valuable in this regard.</para>
          </listitem>

          <listitem>
            <para>Autowiring can cause configuration to keep itself up to date
            as your objects evolve. For example, if you need to add an
            additional dependency to a class, that dependency can be satisfied
            automatically without the need to modify configuration. Thus there
            may be a strong case for autowiring during development, without
            ruling out the option of switching to explicit wiring when the
            code base becomes more stable.</para>
          </listitem>
        </itemizedlist>

        <para>Some disadvantages of autowiring:</para>

        <itemizedlist>
          <listitem>
            <para>Autowiring is more magical than explicit wiring. Although,
            as noted in the above table, Spring Actionscript is careful to
            avoid guessing in case of ambiguity which might have unexpected
            results, the relationships between your Spring
            Actionscript-managed objects are no longer documented
            explicitly.</para>
          </listitem>

          <listitem>
            <para>Wiring information may not be available to tools that may
            generate documentation from a Spring Actionscript
            container.</para>
          </listitem>
        </itemizedlist>

        <para>Another issue to consider when autowiring by type is that
        multiple object definitions within the container may match the type
        specified by the setter method or constructor argument to be
        autowired. For arrays, collections, or maps, this is not necessarily a
        problem. However for dependencies that expect a single value, this
        ambiguity will not be arbitrarily resolved. Instead, if no unique
        object definition is available, an Exception will be thrown. You do
        have several options when confronted with this scenario. First, you
        may abandon autowiring in favor of explicit wiring. Second, you may
        designate that certain object definitions are never to be considered
        as candidates by setting their '<emphasis
        role="bold">autowire-candidate</emphasis>' attributes to '<emphasis
        role="bold">false</emphasis>' as described in the next section. Third,
        you may designate a single object definition as the primary candidate
        by setting the '<emphasis role="bold">primary</emphasis>' attribute of
        its <emphasis role="bold"
        xlink:href="dtd://anchor_objectType">&lt;object/&gt;</emphasis>
        element to '<emphasis role="bold">true</emphasis>'.</para>

        <para>When deciding whether to use autowiring, there is no wrong or
        right answer in all cases. A degree of consistency across a project is
        best though; for example, if autowiring is not used in general, it
        might be confusing to developers to use it just to wire one or two
        object definitions.</para>

        <note>
          <para>If a property is of type IApplicationContext or
          ApplicationDomain the application context instance or its
          ApplicationDomain will be injected when autowiring byType.</para>
        </note>
      </section>

      <section xml:id="a_graphical_overview_of_the_autowiring_flow_of_an_object">
        <title>A graphical overview of the autowiring flow of an
        object</title>

        <para>As you can see its possible to combine the different types of
        wiring, the types take this override precedence:</para>

        <orderedlist>
          <listitem>
            <para>Wire properties explicitly defined in the
            <literal>IObjectDefinition</literal> from the configuration</para>
          </listitem>

          <listitem>
            <para>Wire properties by name or type as defined by the class
            annotations (metadata)</para>
          </listitem>

          <listitem>
            <para>Wire properties by name or type as defined in the
            IObjectDefinition</para>
          </listitem>
        </orderedlist>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="images/autowiringflow.png" format="PNG"></imagedata>
            </imageobject>
          </inlinemediaobject></para>
      </section>

      <section xml:id="autowiring_objects_using_annotations">
        <title>Autowiring objects using annotations</title>

        <para>A different way of letting the Spring Actionscript container
        know how to configure an object is by adding specific metadata
        annotations to the component's sources. Obviously this is only
        possible when the developer actually has access to the source code.
        Thus, this solution does not apply to the situation in which you'd
        like to autowire existing objects, such as the ones that are already
        part of the Flex framework.</para>

        <para>The simplest way to inject a property by type is by decorating
        its source like this:</para>

        <programlisting>public class ExampleComponent extends UIComponent {

 <emphasis role="bold">[Autowired]</emphasis>
 public var modelInstance:IModelLocator;

 public function ExampleComponent() {
  super();
 }

}</programlisting>

        <para>Once this component is created (or added to the stage), the
        Spring Actionscript container will search in its container an object
        of type <emphasis>IModelLocator</emphasis> and assign it to the
        modelInstance property of the ExampleComponent.</para>

        <para>Wiring by name is also possible, all that is needed is a little
        extra metadata:</para>

        <programlisting>public class ExampleComponent extends UIComponent {

 <emphasis role="bold">[Autowired(mode='byName')]</emphasis>
 public var modelInstance:IModelLocator;

 public function ExampleComponent() {
  super();
 }

}</programlisting>

        <para>Now the Spring Actionscript container will look for an object in
        its configuration with the id 'modelInstance' and assign this to the
        modelInstance property of the ExampleComponent.</para>

        <para>There's another way of injecting by name, suited for the
        situation where the name of the property and the id in the
        configuration don't match. What if the
        <emphasis>IModelLocator</emphasis> instance described in the
        configuration has an id called 'modelLocator' and for some reason this
        can't be easily changed?</para>

        <para>Easy, you can define the exact name in the metadata as
        follows:</para>

        <programlisting>public class ExampleComponent extends UIComponent {

 <emphasis role="bold">[Autowired(name='ModelLocator')]</emphasis>
 public var modelInstance:IModelLocator;

 public function ExampleComponent() {
  super();
 }

}</programlisting>

        <note>
          <para>When using the Autowired metadata do not forget to add these
          compiler settings to your Flex project: <emphasis
          role="bold">-keep-as3-metadata += Autowired</emphasis>.</para>

          <para>Apparently Flexbuilder on OSX behaves slightly different and
          needs you to add the metadata one-by-one and quoted, like this:
          <emphasis role="bold">-keep-as3-metadata
          "Autowired".</emphasis></para>
        </note>
      </section>

      <section xml:id="binding_a_stage_component_to_a_property_of_an_object_in_the_container">
        <title>Binding an object property to a property of an object in the
        container</title>

        <para>To keep your objects as decoupled as possible it might be
        preferred not to inject the modelInstance into it, but just a certain
        property of the model. Since the data in the model is subject to
        change (usually it is populated with data retrieved from remote method
        invocations), it would also be good to bind your view to the
        model.</para>

        <para>This can be achieved by using the following metadata:</para>

        <programlisting>public class ExampleProductListComponent extends UIComponent {

 <emphasis role="bold">[Autowired(name='ModelLocator',property='products')]</emphasis>
 public var products:ArrayCollection;

 public function ExampleProductListComponent() {
  super();
 }

}</programlisting>

        <para>This example assumes that the ModelLocator object has a property
        called 'products' of type ArrayCollection. A binding is established
        between these two objects, so when the products ArrayCollection in the
        model in updated, so will the component.</para>

        <para>The property value can also be a chain of objects, so this will
        work as well:<programlisting>public class ExampleProductListComponent extends UIComponent {

 <emphasis role="bold">[Autowired(name='ModelLocator',property='productManager.products')]</emphasis>
 public var products:ArrayCollection;

 public function ExampleProductListComponent() {
  super();
 }

}</programlisting></para>

        <note>
          <para>Since this functionality makes use of Flex binding it is
          therefore only available through the <literal
          xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>.</para>
        </note>
      </section>

      <section xml:id="injecting_a_stage_component_property_with_an_external_property_value">
        <title>Injecting an object property with an external property
        value</title>

        <para>Its also possible to inject the value of an external property
        into a stage component. (If you want to know more about external
        properties read the section '<link
        linkend="external_property_files">External property
        files</link>').</para>

        <para>To do this add metadata to your source like this:</para>

        <programlisting>public class ExampleComponent extends UIComponent {

 <emphasis role="bold">[Autowired(externalProperty='currentURL')]</emphasis>
 public var websiteURL:String;

 public function ExampleComponent() {
  super();
 }

}</programlisting>

        <para>Where the value of the <emphasis
        role="bold">propertyName</emphasis> metadata argument key matches the
        key in one of the loaded property files.</para>
      </section>

      <section xml:id="instantiating_a_class_with_autowire_annotations">
        <title>Instantiating a Class with [Autowired] annotations</title>

        <para>When a Class only uses [Autowired] annotations to define its
        dependencies it is a waste to have to add an object definition for
        these classes to the XML configuration. Therefore its also possible to
        directly let the application context instantiate the class:</para>

        <programlisting>var example:ExampleObject = applicationContext.createInstance(ExampleObject);</programlisting>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory#createInstance()">createInstance()</literal>
        method will instantiate the Class and pass it through the rest of the
        wiring pipeline, so also object post processing and metadata
        wiring.</para>
      </section>

      <section xml:id="autowiring_stage_components">
        <title>Autowiring stage components</title>

        <para>Spring Actionscript has one situation when used in conjunction
        with the Flex framework which differs from other Spring
        implementations. This is when visual components (often declared as
        <abbrev>MXML</abbrev> components) need to be autowired. In this case
        the container can't be responsible for the actual creation of the
        components, so it is deferred back to the Flex application.</para>

        <para>Concretely, we want to retain the expressiveness of
        <abbrev>MXML</abbrev> declaration and combine it with the
        <abbrev>IoC</abbrev> capabilities of Spring Actionscript.</para>

        <para>For example, given this (very simple) piece of
        <abbrev>MXML</abbrev> markup:<programlisting>&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;mx:Application
 xmlns:mx="http://www.adobe.com/2006/mxml"
 <emphasis role="bold">xmlns:custom="http://www.mydomain.com/flexcomponents"</emphasis>
 layout="vertical"&gt;

 <emphasis role="bold">&lt;custom:OrderView myDependency="{this.applicationModel}"/&gt;</emphasis>

&lt;/mx:Application&gt;</programlisting></para>

        <para>In this case the application model instance is directly injected
        through concrete markup. In a lot of cases this is perfectly
        acceptable, but Spring Actionscript offers a little extra flexibility
        by being able to inject the model instance at runtime.</para>

        <para>Spring Actionscript is able to perform these dependency
        injections by hooking an event listener into the <emphasis
        role="bold">Event.ADDED_TO_STAGE</emphasis> event and process the
        components right after they have been added to the stage.</para>

        <para>To make use of the metadata processor that handles all of the
        functionality described in the following sections add this to the
        <abbrev>XML</abbrev> configuration:</para>

        <para><programlisting>&lt;object id="autowiringStageProcessor" class="org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor"/&gt;</programlisting>There
        are several ways of configuration for this stituation, in the
        following sections we will look at them one by one.</para>

        <note>
          <para>Spring Actionscript will wait until the container has finished
          loading and parsing its configuration, after which it will loop
          through the entire current displaylist once to autowire the already
          created stage components.</para>
        </note>

        <note>
          <para>If you'd like to learn more about the underlying architecture
          of stage wiring and how to extend it, check out the section <link
          linkend="the_istageprocessor_interface">'The IStageProcessor
          interface'</link>.</para>
        </note>

        <note>
          <para>You can force the autowiring process to ignore the metadata on
          a given object by setting its <emphasis>skip-metadata</emphasis>
          attribute to <emphasis role="bold">true</emphasis>. This will yield
          a small performance boost.</para>
        </note>
      </section>

      <section>
        <title>Autowiring stage components in a pure actionscript
        project</title>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>
        take care all by itself of creating the necessary objects to
        facilitate stage wiring. In a pure actionscript situation, however, a
        little bit of extra code is required. The stage wiring system needs at
        one point to have a reference to the stage. In case of Flex this is
        easy, the SystemManager singleton is used. In case of pure
        actionscript, the stage property will have to be set manually before
        any <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>
        has been created. Add this code before the context's
        instantiation:</para>

        <programlisting><emphasis role="bold">FlashStageProcessorRegistry.getInstance().stage = stage;</emphasis> <lineannotation>//this being a valid reference to the flash player's stage</lineannotation>
context = new XMLApplicationContext('application-context.xml');
context.addEventListener(Event.COMPLETE, completeHandler);
context.load();
<lineannotation>//etc...</lineannotation></programlisting>
      </section>

      <section xml:id="autowiring_stage_components_using_xml_configuration">
        <title>Autowiring stage components using XML configuration</title>

        <para>Stage components can be configured using metadata that describes
        the desired injections, but this can also be entirely expressed in
        <abbrev>XML</abbrev> metadata. Here is how to configure the
        ExampleComponent to be autowired by type:</para>

        <programlisting>&lt;object id="exampleComponent" class="classes.components.ExampleComponent" <emphasis
            role="bold">autowire="byType"</emphasis> singleton="false"/&gt;</programlisting>

        <para>In this example we assume that the ExampleComponent instance on
        the stage has an id with the value
        <emphasis>exampleComponent</emphasis>.</para>

        <para>Let us be clear immediately though, autowiring a stage component
        in this way is a <emphasis role="bold">bad</emphasis> idea. The Spring
        Actionscript container will, in this case, actually loop through
        <emphasis role="bold">every</emphasis> property of the
        ExampleComponent instance and try to find a matching wiring candidate
        in the container. This will very quickly become very slow, so please
        regard this example as a proof of concept but don't use it in any
        actual production code.</para>

        <para>Autowiring by name is almost the same and the same warning as
        the wiring by type is applicable: <emphasis>don't do
        it.</emphasis><programlisting>&lt;object id="exampleComponent" class="classes.components.ExampleComponent" <emphasis
              role="bold">autowire="byName"</emphasis> singleton="false"/&gt;</programlisting></para>

        <para>The most obvious way of configuring the ExampleComponent is by
        simply injecting the property explicitly like this:</para>

        <programlisting>&lt;object id="exampleComponent" class="classes.components.ExampleComponent" singleton="false"&gt;
 &lt;property name="modelInstance" ref="ModelLocator"/&gt;
&lt;/object&gt;</programlisting>

        <para><note>
            <para>Do take notice of the singleton="false" attribute on each of
            these configuration examples. Don't forget to add this value to
            each and every stage component definition entry. Spring
            Actionscript defaults an object definition to a singleton scope
            and instantiates every singleton in the configuration at startup.
            Failing to add the singleton="false" attribute will result in
            Spring Actionscript creating a whole bunch of stage component
            instances unnecessarily.</para>
          </note></para>
      </section>

      <section xml:id="how_to_determine_which_stage_components_are_eligeble_for_configuration">
        <title>How to determine which stage components are eligible for
        configuration</title>

        <para>The <emphasis role="bold">Event.ADDED_TO_STAGE</emphasis> event
        is fired a <emphasis>lot</emphasis> during the lifetime of a Flex
        application. It is therefore paramount to make the event handler as
        efficient as possible and thus determine as quickly as possible if the
        component in question is eligible for configuration or not.</para>

        <para>Again Spring Actionscript offers several ways to do this. First
        of all we introduce the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector"
        xlink:role="">IObjectSelector</literal> interface. This interface is a
        modest one:</para>

        <programlisting>public interface IObjectSelector {
 function approve(object:Object):Boolean;
}</programlisting>

        <para>An object that implements this interface is responsible for
        determining whether a specific instance is eligible for autowiring.
        The how and why is up to the implementation. Spring Actionscript by
        default uses a <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.FlexStageDefaultObjectSelector">FlexStageDefaultObjectSelector</literal>
        instance.</para>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.FlexStageDefaultObjectSelector">FlexStageDefaultObjectSelector</literal>
        is a fairly simple implementation of the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
        interface that, by default, rejects any component whose namespace
        starts with either 'flash.*' or 'mx.*', after that it checks if the
        specified object inherits from UIComponent, if not, the object is
        rejected as well. (This is to prevent embedded images in skins from
        clogging up the wiring pipeline).</para>

        <para>Once a component is approved by the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
        it will be ready for configuration, the exact wiring information will
        be determined by either reading the metadata or retrieving an object
        definition from the configuration.</para>

        <para>Naturally, Spring Actionscript also offers you the possibility
        to easily implement and plug in your own <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
        implementations. Let's have a look at how this works.</para>

        <section xml:id="creating_and_using_a_custom_iobjectselector">
          <title>Creating and using a custom IObjectSelector
          implementation</title>

          <para>By default the <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor">DefaultAutowiringStageProcessor</literal>
          is fitted with a <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.FlexStageDefaultObjectSelector">FlexStageDefaultObjectSelector</literal>
          to approve or reject stage components that have been added to the
          stage. To override this behaviour you can create your own <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
          implementation and add an object definition for it in the
          <abbrev>XML</abbrev> configuration. A custom implementation might
          look something like this in your configuration:</para>

          <programlisting>&lt;object id="flexStageObjectSelector" class="com.classes.objectselectors.MyCustomObjectSelector"/&gt;</programlisting>

          <para>To use this <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
          instance you must also override the default autowiring processor
          with a new instance and assign this object selector to it:</para>

          <programlisting>&lt;object class="org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor" id="<emphasis
              role="bold">defaultAutowiringStageProcessor</emphasis>"&gt;
  &lt;property name="objectSelector" ref="flexStageObjectSelector"/&gt;
&lt;/object&gt;</programlisting>
        </section>
      </section>

      <section xml:id="how_to_determine_which_objectdefinition_to_use_for_which_stage_component">
        <title>How to determine which object definition to use for which stage
        component</title>

        <para>Once a stage component is approved by an <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
        instance the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor">DefaultAutowiringStageProcessor</literal>
        might need an object definition to be able to pass it on to the
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.IDependencyInjector#wire()">wire()</literal>
        method of the object factory (this value can also be null, for the
        case where the components are solely configured with annotations).
        This particular task is bestowed upon the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.IObjectDefinitionResolver">IObjectDefinitionResolver</literal>
        interface. Like the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>,
        this interface is a simple one:</para>

        <programlisting>public interface IObjectDefinitionResolver {
 function resolveObjectDefinition(object:*):IObjectDefinition;
}</programlisting>

        <para>An object that implements this interface is responsible for
        retrieving, or creating, an object definition for a given object
        instance. Spring Actionscript by default offer the <literal
        xlink:arcrole=""
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.DefaultObjectDefinitionResolver">DefaultObjectDefinitionResolver
        </literal>class. This implementation uses different strategies to
        retrieve the appropriate <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.IObjectDefinition">IObjectDefinition</literal>
        for an object. First of all it uses the value of its <literal
        xlink:arcrole=""
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.DefaultObjectDefinitionResolver#objectIdProperty()">objectIdProperty</literal>
        property to find the object definition by name. By default the value
        of this property is '<emphasis role="bold">name</emphasis>'. This
        means that if a stage component is being examined whose
        <emphasis>name</emphasis> property has a value of '<emphasis
        role="bold">MyStageComponent</emphasis>', the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.DefaultObjectDefinitionResolver">DefaultObjectDefinitionResolver</literal>
        will look for an object definition with an id of '<emphasis
        role="bold">MyStageComponent</emphasis>'. If the object definition
        can't be found it will fall back on trying to find an object
        definition by type, but only if the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.DefaultObjectDefinitionResolver#lookupByType()">lookupByType</literal>
        property on the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.DefaultObjectDefinitionResolver">DefaultObjectDefinitionResolver</literal>
        is set to true.</para>

        <para>If both of these options fail the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.DefaultObjectDefinitionResolver">DefaultObjectDefinitionResolver</literal>
        will return null. This will happen in the case that a stage component
        has been decorated with autowiring metadata and has no further use for
        an object definition. Of course, the both can combined as well, but
        its open to discussion whether this is advisable. To use the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.DefaultObjectDefinitionResolver">DefaultObjectDefinitionResolver</literal>
        use this <abbrev>XML</abbrev> configuration:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor" id="<emphasis
            role="bold">defaultAutowiringStageProcessor</emphasis>"&gt;
  &lt;property name="<emphasis role="bold">objectDefinitionResolver</emphasis>"&gt;
    <emphasis role="bold">&lt;object id="defaultObjectDefinitionResolver"
      class="org.springextensions.actionscript.stage.DefaultObjectDefinitionResolver"/&gt;</emphasis>
  &lt;/property&gt;
&lt;/object&gt;</programlisting>

        <para>Just like the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
        its also possible to plug in your own <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.IObjectDefinitionResolver">IObjectDefinitionResolver</literal>
        implementation. What follows is how to do this.</para>

        <section xml:id="creating_and_using_a_custom_iobjectdefinitionresolver">
          <title>Creating and using a custom IObjectDefinitionResolver
          implementation</title>

          <para>By default the <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor">DefaultAutowiringStageProcessor</literal>
          is fitted with a <literal xlink:arcrole=""
          xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.DefaultObjectDefinitionResolver"
          xlink:role="">DefaultObjectDefinitionResolver</literal> to retrieve
          an appropriate <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.IObjectDefinition">IObjectDefinition</literal>
          instance for a given object. To override this behaviour you can
          create your own <literal xlink:arcrole=""
          xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.IObjectDefinitionResolver">IObjectDefinitionResolver</literal>
          implementation and add an object definition for it in the XML
          configuration. So you can simply add your <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.DefaultObjectDefinitionResolver">IObjectDefinitionResolver</literal>
          implementation as follows:</para>

          <programlisting>&lt;object id="flexStageObjectDefinitionResolver" class="com.classes.definitionresolvers.MyCustomDefinitionResolver"/&gt;</programlisting>

          <para>To use this <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.DefaultObjectDefinitionResolver">IObjectDefinitionResolver</literal>
          instance you must also override the default autowiring processor
          with a new instance and assign this object selector to it:</para>

          <programlisting>&lt;object class="org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor" id="<emphasis
              role="bold">defaultAutowiringStageProcessor</emphasis>"&gt;
  &lt;property name="objectSelector" ref="flexStageObjectSelector"/&gt;
  &lt;property name="objectDefinitionResolver" ref="flexStageObjectDefinitionResolver"/&gt;
&lt;/object&gt;</programlisting>
        </section>

        <section xml:id="optimizing_the_stage_component_selection_process">
          <title>Optimizing the stage component selection process</title>

          <para>The <emphasis role="bold">Event.ADDED_TO_STAGE</emphasis> that
          is being used by the stage wiring system gets dispatched a LOT in
          the lifetime of a Flex application. It is therefore paramount to
          keep the selection and wiring process as optimized as possible.
          First of all it is recommended to use a custom <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
          as much as possible. The one created by default by the <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor">DefaultAutowiringStageProcessor</literal>,
          the <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.FlexStageDefaultObjectSelector">FlexStageDefaultObjectSelector</literal>,
          uses this code for the selection process:</para>

          <programlisting>public function approve(object:Object):Boolean {

  var className:String;
  try {
    className = getQualifiedClassName(object);
  } catch (e:*) {
    return false;
  }

  if (className.search("^spark.*") &gt; -1 || className.search("^flash.*") &gt; -1 || className.search("^mx.*") &gt; -1 || className.indexOf("_") &gt; -1) {
    return false;
  }

  if (!(object is UIComponent)) {
    return false;
  }

  try {
    ObjectUtils.getClass(object);
    return true;
  } catch (e:*) {
  }

  return false;
}
</programlisting>

          <para>These are quite a few calls for <emphasis>every</emphasis>
          component being added to the stage. Now, imagine a situation where
          you know beforehand that only components that implement a specific
          marker interface need to be autowired. In that case you can
          implement a much simpler selection process. Let's say the marker
          interface is called IAutowiredComponent, then the implementation of
          the <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.IObjectDefinition#approve()">approve()</literal>
          method needs to be simply this:</para>

          <programlisting>public function approve(object:Object):Boolean {
 return (object is IAutowiredComponent);
}
</programlisting>
        </section>
      </section>

      <section xml:id="injecting_stage_components_into_other_objects">
        <title>Injecting stage components into other objects</title>

        <para>It is also possible to inject a stage component into a 'regular'
        object. To achieve this Spring Actionscript offers an <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>
        implementation called <literal xlink:arcrole=""
        xlink:href="asdoc://org.springextensions.actionscript.stage.GenericStageProcessor">GenericStageProcessor</literal>.
        What this stageprocessor does is it will assign a component that was
        added to the stage to a previously configured object. This assignment
        can either be done by property assignement or method
        invocation.</para>

        <para>To determine which object will 'receive' the selected components
        the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.GenericStageProcessor">GenericStageProcessor</literal>
        has a property called <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.GenericStageProcessor#targetObject">targetObject</literal>.
        This <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.GenericStageProcessor#targetObject">targetObject</literal>
        is a reference to another object that is declared in the application
        context, so to configure the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.GenericStageProcessor">GenericStageProcessor</literal>
        you will need to add this markup to your application context:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.stage.GenericStageProcessor" id="stageProcessor"&gt;
  &lt;property name="targetObject" ref="stageComponentRegistry"/&gt;
&lt;/object&gt;</programlisting>

        <para>Let's say this stageComponentRegistry object has a method called
        registerComponent that is used to gather a list of stage components.
        To have the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.GenericStageProcessor">GenericStageProcessor</literal>
        invoke this method with each stage component it approves, add this bit
        of markup:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.stage.GenericStageProcessor" id="stageProcessor"&gt;
  &lt;property name="targetObject" ref="stageComponentRegistry"/&gt;
  <emphasis role="bold">&lt;property name="targetMethod" value="registerComponent"/&gt;</emphasis>
&lt;/object&gt;</programlisting>

        <para>Right, that was easy so far. Now all we need to do is put the
        mechanism in place that will determine which stage components will be
        passed to the stageComponentRegistry instance. For this we need to
        declare an <literal>IObjectSelector</literal> instance, in this
        example we use one of the pre-existing implementations offered by
        Spring Actionscript called <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.ClassBasedObjectSelector"
        xlink:role="">ClassBasedObjectSelector</literal>. This <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
        approves objects based on their classname and uses regular expressions
        to evaluate these names. To add the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.wire.ClassBasedObjectSelector">ClassBasedObjectSelector</literal>
        to your application add this markup:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.ioc.wire.ClassBasedObjectSelector" id="registrySelector"&gt;
  &lt;property name="approveOnMatch" value="true"/&gt;
  &lt;property name="classRegexpArray"&gt;
    &lt;value&gt;
      &lt;array&gt;
        &lt;value&gt;com\.components*&lt;/value&gt;
      &lt;/array&gt;
    &lt;/value&gt;
  &lt;/property&gt;
&lt;/object&gt;</programlisting>

        <para>Change the regular expression pattern to suit your own
        needs.</para>

        <para>After this all we need to do is assign this selector to the
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.GenericStageProcessor">GenericStageProcessor</literal>
        like this:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.stage.GenericStageProcessor" id="stageProcessor"&gt;
  &lt;property name="targetObject" ref="stageComponentRegistry"/&gt;
  &lt;property name="targetMethod" value="registerComponent"/&gt;
  <emphasis role="bold">&lt;property name="objectSelector" ref="registrySelector"/&gt;</emphasis>
&lt;/object&gt;</programlisting>

        <para>And that's it, from now on every component that is added to the
        stage and has a class name that starts with
        <emphasis>com.components</emphasis> will be passed to the
        registerComponent method of the stageComponentRegistry object.</para>

        <para>To make life a little easier by reducing the amount of markup
        for the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.GenericStageProcessor">GenericStageProcessor</literal>
        Spring Actionscript also offers a custom namespace with some special
        markup for this class. See The <link
        linkend="the_stage_processing_schema">Stage Processing schema</link>
        for more details.</para>
      </section>

      <section xml:id="implementing_custom_autowiring_support_using_the_iautowireprocessor_interface">
        <title>Implementing custom autowiring support using the
        IAutowireProcessor interface</title>

        <para>Spring Actionscript wouldn't be Spring Actionscript if it didn't
        allow you to implement your own brand of autowiring. Naturally the
        Spring Actionscript team is of the opinion that the offered autowiring
        functionality is about as broad as one can imagine, but should the
        need arise to step outside the confines of Spring Actionscript
        autowiring than this entirely possible.</para>

        <para>In this particular case the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.autowire.IAutowireProcessor">IAutowireProcessor</literal>
        is your friend. And as you are used to, its not a very complicated
        one, see for yourself:</para>

        <programlisting>public interface IAutowireProcessor {

 function autoWire(object:Object, objectDefinition:IObjectDefinition, objectName:String=null):void;

 function preprocessObjectDefinition(objectDefinition:IObjectDefinition):void;
}
</programlisting>

        <para>The first method is the main <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.autowire.IAutowireProcessor#autoWire()">autoWire()</literal>
        method that is invoked by the object container immediately after
        creation. (see <link
        linkend="a_graphical_overview_of_the_wiring_flow_of_an_object">'A
        graphical overview of the wiring flow of an object'</link> for more
        details.)</para>

        <para>The second method is invoked by the container right before an
        object is actually created, so this would typically be a good moment
        to change any kind of constructor argument autowiring or perhaps
        change the autowiring strategy of the current <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.IObjectDefinition">IObjectDefinition</literal>
        based on some pre-configured logic.</para>

        <para>As you can see in the default implementation used by the
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.support.AbstractObjectFactory">AbstractObjectFactory</literal>,
        (fittingly titled <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.autowire.DefaultAutowireProcessor">DefaultAutowireProcessor</literal>),it
        is also possible for your own <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.autowire.IAutowireProcessor">IAutowireProcessor</literal>
        implementation to include the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactoryAware">IObjectFactoryAware</literal>
        interface. If your instance implements this particular interface it
        will automatically be injected by the object factory instance to which
        the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.autowire.IAutowireProcessor">IAutowireProcessor</literal>
        is assigned.</para>

        <para>Now, after you've created your own implementation, its time to
        hook it up to the object container, typically this would be done
        something like this:</para>

        <programlisting>var xmlApplicationContext:XMLApplicationContext = new XMLApplicationContext();
xmlApplicationContext.autowireProcessor = new MyCustomAutowireProcessor();</programlisting>

        <para>After that your own autowiring logic will be performed on any
        object created by the <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>
        instance.</para>

        <note>
          <para>Consequently, when you don't need the autowiring functionality
          at all in your application, it might be an idea to set the <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.support.AbstractObjectFactory#autowireProcessor">autowireProcessor</literal>
          property to null as this will yield a small performance
          benefit.</para>
        </note>
      </section>

      <section xml:id="the_istageprocessor_interface">
        <title>The IStageProcessor interface</title>

        <para>The underlying architecture for stage component wiring can be
        easily extended, the basics are very simple: An <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessorRegistry">IStageProcessorRegistry</literal>
        implementation (in most cases that would be the <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>)
        adds an event listener to the SystemManager and listens for an
        <emphasis role="bold">Event.ADDED_TO_STAGE</emphasis> event to be
        fired. After that an <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
        instance determines whether the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor">DefaultAutowiringStageProcessor</literal>
        should process the object or not.</para>

        <para>Here's a quick overview of how the IStageProcessorRegistry,
        IObjectSelector and IStageProcessor interfaces work together:</para>

        <para><mediaobject>
            <imageobject>
              <imagedata fileref="images/stageprocessingflow.png"></imagedata>
            </imageobject>
          </mediaobject></para>

        <para>This pattern can naturally be used to perform other kinds of
        operations on stage components.</para>

        <note>
          <para>To automatically register any <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>
          instances declared in the configuration, a <literal
          xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>
          instance creates a <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.StageProcessorFactoryPostprocessor">StageProcessorFactoryPostprocessor</literal>
          for itself.</para>
        </note>

        <para>As you can see the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor">DefaultAutowiringStageProcessor</literal>
        is an implementation of the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>
        interface, this interface is, as usual, fairly simple:</para>

        <programlisting>public interface IStageProcessor {

 function get selector():IObjectSelector;

 function set selector(value:IObjectSelector):void;

 function process(object:Object):Object;
}</programlisting>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
        instance can be shared among <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>
        instances, so that way only one <literal>IObjectSelector</literal>'s
        approval can invoke multiple <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor#process()">process()</literal>
        methods. So, if you want the same <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
        to also trigger your custom <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>,
        add their configurations like this:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.ioc.wire.ClassBasedObjectSelector" id="globalSelector"&gt;
  &lt;property name="approveOnMatch" value="true"/&gt;
  &lt;property name="classRegexpArray"&gt;
    &lt;value&gt;
      &lt;array&gt;
        &lt;value&gt;com\.components*&lt;/value&gt;
      &lt;/array&gt;
    &lt;/value&gt;
  &lt;/property&gt;
&lt;/object&gt;

&lt;object class="org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor" id="defaultAutowiringStageProcessor"&gt;
  &lt;property name="objectSelector" ref="globalSelector"/&gt;
  &lt;property name="objectDefinitionResolver" ref="flexStageObjectDefinitionResolver"/&gt;
&lt;/object&gt;

&lt;object class="com.classesMyCustomStageProcessor" id="myCustomStageProcessor"&gt;
  &lt;property name="objectSelector" ref="globalSelector"/&gt;
&lt;/object&gt;
</programlisting>

        <para>Although probably you will need different approval strategies
        for each <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>
        instance, in that case declare separate <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IObjectSelector">IObjectSelector</literal>
        instances per <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>.</para>

        <note>
          <para>For another example of an <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>
          implementation, see the section <link
          linkend="injecting_stage_components_into_other_objects">'Injecting
          stage components into other objects'</link>.</para>
        </note>

        <section xml:id="the_localizationstageprocessor_class">
          <title>The LocalizationStageProcessor class</title>

          <para>A good example of an <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>
          implementation is the <literal
          xlink:href="asdoc://org.springextensions.actionscript.localization.LocalizationStageProcessor">LocalizationStageProcessor</literal>,
          found in the <literal
          xlink:href="asdocpackage://org.springextensions.actionscript.localization">org.springextensions.actionscript.localization</literal>
          package. This class enables you to assign resource values to stage
          components at runtime based on the value of the component's id. To
          use this class add this bit of markup to your configuration:</para>

          <programlisting>&lt;object id="resourceManager" class="mx.resources.ResourceManager" factory-method="getInstance"/&gt;

&lt;object id="localizationProcessor" class="org.springextensions.actionscript.localization.LocalizationStageProcessor"&gt;
 &lt;property name="resourceManager" ref="resourceManager"/&gt;
 &lt;property name="bundleName" value="<emphasis role="bold">mySampleResources</emphasis>"/&gt;<lineannotation>&lt;!-- change this to the name of your bundle --&gt;</lineannotation>
&lt;/object&gt;
</programlisting>

          <para>The <literal
          xlink:href="asdoc://org.springextensions.actionscript.localization.LocalizationStageProcessor">LocalizationStageProcessor</literal>
          uses a <literal
          xlink:href="asdoc://org.springextensions.actionscript.stage.selectors.PropertyValueBasedObjectSelector">PropertyValueBasedObjectSelector</literal>
          instance by default, this selector approves only components whose id
          property is set. When the <literal
          xlink:href="asdoc://org.springextensions.actionscript.localization.LocalizationStageProcessor">LocalizationStageProcessor</literal>
          receives a component it will use its id as a base name to look up
          resource strings and assign these to arbitrary properties on the
          component. For instance, if a button is added to the stage with an
          id called 'myButton' and you want the label property on the button
          to be set to 'Click me' add a resource string like this:</para>

          <programlisting>myButton_label=Click me</programlisting>

          <para>If you want the tooltip property to be set to 'Click this
          button for fun!', then add a resource string like this:</para>

          <programlisting>myButton_toolTip=Click this button for fun!</programlisting>

          <para>By default the <literal
          xlink:href="asdoc://org.springextensions.actionscript.localization.LocalizationStageProcessor">LocalizationStageProcessor</literal>
          looks for resource strings for the following property names:
          <emphasis>text, label, toolTip, prompt, dataProvider, title,
          headerText.</emphasis></para>

          <para>To add to this list, or replace it with your own array of
          names, use the <literal
          xlink:href="asdoc://org.springextensions.actionscript.localization.LocalizationStageProcessor">LocalizationStageProcessor</literal>'s
          <literal
          xlink:href="asdoc://org.springextensions.actionscript.localization.LocalizationStageProcessor#resourceSuffixes">resourceSuffixes</literal>
          property.</para>

          <para>There is a sample project that demonstrates the <literal
          xlink:href="asdoc://org.springextensions.actionscript.localization.LocalizationStageProcessor">LocalizationStageProcessor</literal>
          class, you can take a look by following this <literal
          xlink:href="/test-apps/localization/localization.swf">link</literal>.</para>

          <note>
            <para>To learn more about flex resource management, follow this
            <literal
            xlink:href="http://labs.adobe.com/wiki/index.php/Flex_3:Feature_Introductions:_Runtime_Localization">link</literal>.</para>
          </note>
        </section>

        <section xml:id="the_simplesecuritystageprocessor_class">
          <title>The SimpleSecurityStageProcessor class</title>

          <para>The stage processing pattern can also be used to add role and
          rights based security to an application. For this specific task
          Spring Actionscript offers the <literal
          xlink:href="asdocpackage://org.springextensions.actionscript.security">org.springextensions.actionscript.security</literal>
          package. Part of this package is the <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.SimpleSecurityStageProcessor">SimpleSecurityStageProcessor</literal>
          which is able to create a <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.SimpleStageSecurityManager">SimpleStageSecurityManager</literal>
          for specified components after they have been added to the
          stage.</para>

          <para>To add the <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.SimpleSecurityStageProcessor">SimpleSecurityStageProcessor</literal>
          to your configuration add this bit of markup:</para>

          <programlisting>&lt;object id="securityProcessor" class="org.springextensions.actionscript.security.SimpleSecurityStageProcessor"/&gt;</programlisting>

          <para>Now just adding this stage processor to your application
          context isn't going to achieve much. Somehow the data needed to
          create what kind of <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.SimpleStageSecurityManager">SimpleStageSecurityManager</literal>
          for which stage component needs to be fed to the stage
          processor.</para>

          <para>The <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.SimpleSecurityStageProcessor">SimpleSecurityStageProcessor</literal>
          creates a <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.SimpleSecurityManagerFactory">SimpleSecurityManagerFactory</literal>
          instance for itself by default, this <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.ISecurityManagerFactory">ISecurityManagerFactory</literal>
          implementation uses a Dictionary of <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.MembershipAccessData">MembershipAccessData</literal>
          to hold the membership information for stage components. The key of
          the Dictionary is the id of the stage component to which the
          <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.MembershipAccessData">MembershipAccessData</literal>
          is applicable. The <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.MembershipAccessData">MembershipAccessData</literal>
          determines which roles and rights are applicable and what strategy
          is to be used to restrict access to the component.</para>

          <para>For example, to assign the right called '<emphasis
          role="bold">canClickButton</emphasis>' to a Button instance with the
          id '<emphasis role="bold">myButton</emphasis>' and to have the
          button be invisible when access is restricted, create a <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.MembershipAccessData">MembershipAccessData</literal>
          instance like this:</para>

          <programlisting>var md:MembershipAccessData = new MembershipAccessData();
md.rights.push("<emphasis role="bold">canClickButton</emphasis>");
md.accessStrategy = AccessStrategy.VISIBLE;
</programlisting>

          <para>To have this membership data be used by the stage processor,
          assign it like this:</para>

          <programlisting>var sp:SimpleSecurityStageProcessor = _applicationContext.getObject("securityProcessor") as SimpleSecurityStageProcessor;
(sp.securityManagerFactory as SimpleSecurityManagerFactory).membershipData["<emphasis
              role="bold">myButton</emphasis>"] = md;
</programlisting>

          <para>This will cause the <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.SimpleSecurityStageProcessor">SimpleSecurityStageProcessor</literal>
          to create a <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.SimpleSecurityManager">SimpleSecurityManager</literal>
          instance for the button instance with id '<emphasis
          role="bold">myButton</emphasis>' after it has been added to the
          stage.</para>

          <para>Finally, the <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.SimpleSecurityManagerFactory">SimpleSecurityManagerFactory</literal>
          needs an <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.IMembershipOwner">IMembershipOwner</literal>
          instance to evaluate against. Typically this would be a user object
          representing the currently logged in user. The <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.IMembershipOwner">IMembershipOwner</literal>
          interface is a modest one and only exposes two properties: rights
          and roles:</para>

          <programlisting>public interface IMembershipOwner extends IEventDispatcher {

 function get roles():Array;
 [Bindable(event="rolesChanged")]
 function set roles(value:Array):void;

 function get rights():Array;
 [Bindable(event="rightsChanged")]
 function set rights(value:Array):void;

}</programlisting>

          <para>You can either have your user object implement this interface
          or simple inherit from the Spring Actionscript <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.SimpleMembershipOwner">SimpleMembershipOwner</literal>
          class.</para>

          <para>Lastly, it is necessary to assign the user object to the
          <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.ISecurityManagerFactory">ISecurityManagerFactory</literal>
          that the stage processor exposes. This enables the <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.ISecurityManager">ISecurityManagers</literal>
          to determine whether they will grant access to their stage
          components for the currently logged in user, based on the roles and
          rights that this user owns.</para>

          <para>You can perform this assignment like so:</para>

          <programlisting>var sp:SimpleSecurityStageProcessor = _applicationContext.getObject("securityProcessor") as SimpleSecurityStageProcessor;
sp.securityManagerFactory.membershipOwner = currentUser; <lineannotation>//Where the currentUser variable is an implementation of IMembershipOwner or a subclass of SimpleMembershipOwner.</lineannotation>
</programlisting>

          <para>And that's it! If the currentUser also owns the right called
          '<emphasis role="bold">canClickButton</emphasis>' the button with id
          '<emphasis role="bold">myButton</emphasis>' will become visible
          after the <emphasis>sp.securityManagerFactory.membershipOwner =
          currentUser</emphasis> assignment has been performed.</para>

          <para>To simulate the user logging out simply set the <literal
          xlink:href="asdoc://org.springextensions.actionscript.security.ISecurityManagerFactory#membershipOwner">membershipOwner</literal>
          property to <emphasis>null</emphasis>.</para>

          <note>
            <para>There is a sample project that demonstrates the <literal
            xlink:href="asdoc://org.springextensions.actionscript.security.SimpleSecurityStageProcessor">SimpleSecurityStageProcessor</literal>
            class, you can take a look by following this <literal
            xlink:href="/test-apps/security/security.swf">link</literal>.</para>
          </note>
        </section>
      </section>

      <section xml:id="the_istagedestroyer_interface">
        <title>The IStageDestroyer interface</title>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>
        interface also has a counterpart called the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageDestroyer">IStageDestroyer</literal>
        interface. Implementations of this interface aim to process a
        component <emphasis>after</emphasis> it has been removed from the
        stage. The <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor">DefaultAutowiringStageProcessor</literal>
        class is also an implementation of this interface and can be used to
        invoke disposal methods on a stage components after its been removed.
        The interface is an extension of <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.IStageProcessor">IStageProcessor</literal>
        and adds only one method:</para>

        <programlisting>public interface IStageDestroyer extends IStageProcessor {
  function destroy(object:Object):Object;
}
</programlisting>

        <para>Implementations can check for interfaces or methods or perform
        other logic which will eventually help the specified object to become
        eligible for garbage collection. See '<link
        linkend="destroying_stage_components">Destroying stage
        components</link>' to find out how the <literal
        xlink:href="asdoc://org.springextensions.actionscript.stage.DefaultAutowiringStageProcessor">DefaultAutowiringStageProcessor</literal>
        goes about this.</para>
      </section>

      <section xml:id="a_graphical_overview_of_the_initialization_of_the_flexxmlapplicationcontext">
        <title>A graphical overview of the initialization of the
        FlexXMLApplicationContext</title>

        <para><inlinemediaobject>
            <imageobject>
              <imagedata fileref="images/flexappcontextwiringflow.png"
                         format="PNG"></imagedata>
            </imageobject>
          </inlinemediaobject></para>
      </section>
    </section>

    <section xml:id="customizing_the_nature_of_an_object">
      <title>Customizing the nature of an object</title>

      <section xml:id="initialization_callbacks">
        <title>Initialization callbacks</title>

        <para>Object definitions provide support for a generic initialization
        method to be specified. In the case of <abbrev>XML</abbrev>-based
        configuration metadata, this is done using the 'init-method'
        attribute. For example, the following definition:</para>

        <programlisting>&lt;object id="exampleInitObject" class="examples.ExampleObject" init-method="init"/&gt;</programlisting>

        <programlisting>public class <classname>ExampleObject</classname> {
    
    public init():void {
        <lineannotation>// do some initialization work</lineannotation>
    }
}</programlisting>

        <para>...is exactly the same as...</para>

        <programlisting>&lt;object id="exampleInitObject" class="examples.ExampleObject"&gt;
    &lt;method-invocation name="init"/&gt;
&lt;/object&gt;</programlisting>

        <para>But a whole lot shorter...</para>
      </section>
    </section>

    <section xml:id="knowing_who_you_are">
      <title>Knowing who you are</title>

      <section xml:id="iapplicationcontextaware">
        <title>IApplicationContextAware</title>

        <para>A class which implements the <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContextAware">IApplicationContextAware</literal>
        interface is provided with a reference to the <literal
        xlink:arcrole=""
        xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>
        or <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>
        that created it, when it is created by that ApplicationContext.</para>

        <programlisting>public interface <literal
            xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContextAware">IApplicationContextAware</literal> {

  function set applicationContext(value:<literal
            xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContextAware">IApplicationContext</literal>):void;

}</programlisting>

        <para>This allows objects to manipulate the <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>
        or <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.XMLApplicationContext">XMLApplicationContext</literal>
        that created them programmatically, through the <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContextAware">IApplicationContextAware</literal>
        interface, or by casting the reference to a known subclass of this
        which exposes additional functionality. Primarily this would consist
        of programmatic retrieval of other objects. While there are cases when
        this capability is useful, it should generally be avoided, since it
        couples the code to Spring Actionscript and does not follow the
        Inversion of Control style, where collaborators are provided to
        objects as properties.</para>
      </section>
    </section>

    <section xml:id="object_definition_inheritance">
      <title>Object definition inheritance</title>

      <para>An object definition potentially contains a large amount of
      configuration information, including container specific information (for
      example initialization method, static factory method name, and so forth)
      and constructor arguments and property values. A child object definition
      is an object definition that inherits configuration data from a parent
      definition. It is then able to override some values, or add others, as
      needed. Using parent and child objects definitions can potentially save
      a lot of typing. Effectively, this is a form of templating.</para>

      <para>When working with an <literal
      xlink:href="asdoc://org.springextensions.actionscript.context.IApplicationContext">IApplicationContext</literal>
      programmatically, child object definitions are represented by the
      ChildObjectDefinition class. Most users will never work with them on
      this level, instead configuring object definitions declaratively. When
      using <abbrev>XML</abbrev>-based configuration metadata a child object
      definition is indicated simply by using the 'parent' attribute,
      specifying the parent object as the value of this attribute.</para>

      <programlisting>&lt;object id="inheritedTestObject" abstract="true" class="org.springactionscript.objects.TestObject"&gt;
  &lt;property name="name" value="parent"/&gt;
  &lt;property name="age" value="1"/&gt;
&lt;/object&gt;

&lt;object id="inheritsWithDifferentClass"
      class="org.springactionscript.objects.DerivedTestObject"
      parent="inheritedTestObject" init-method="initialize"&gt;
    
  &lt;property name="name" value="override"/&gt;
  <lineannotation>&lt;!-- the age property value of 1 will be inherited from  parent --&gt;</lineannotation>
&lt;/object&gt;</programlisting>

      <para>A child object definition will use the object class from the
      parent definition if none is specified, but can also override it. In the
      latter case, the child object class must be compatible with the parent,
      that is it must accept the parent's property values.</para>

      <para>A child object definition will inherit constructor argument
      values, property values and method overrides from the parent, with the
      option to add new values. If any init-method and/or static factory
      method settings are specified, they will override the corresponding
      parent settings.</para>

      <para>The remaining settings will always be taken from the child
      definition: <emphasis>depends on, autowire mode, dependency check,
      singleton, scope, lazy init.</emphasis></para>

      <para>Note that in the example above, we have explicitly marked the
      parent object definition as abstract by using the abstract attribute. In
      the case that the parent definition does not specify a class, and so
      explicitly marking the parent object definition as abstract is
      required:</para>

      <programlisting>&lt;object id="inheritedTestObject" abstract="true"&gt;
  &lt;property name="name" value="parent"/&gt;
  &lt;property name="age" value="1"/&gt;
&lt;/object&gt;

&lt;object id="inheritsWithDifferentClass"
      class="org.springactionscript.objects.DerivedTestObject"
      parent="inheritedTestObject" init-method="initialize"&gt;
    
  &lt;property name="name" value="override"/&gt;
  <lineannotation>&lt;!-- the age property value of 1 will be inherited from  parent --&gt;</lineannotation>
&lt;/object&gt;</programlisting>

      <para>The parent object cannot get instantiated on its own since it is
      incomplete, and it is also explicitly marked as abstract. When a
      definition is defined to be abstract like this, it is usable only as a
      pure template object definition that will serve as a parent definition
      for child definitions. Trying to use such an abstract parent object on
      its own (by referring to it as a ref property of another object, or
      doing an explicit <literal
      xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory#getObject()">getObject</literal>()
      call with the parent object id), will result in an error. Similarly, the
      container's internal <literal
      xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IConfigurableListableObjectFactory#preInstantiateSingletons()">preInstantiateSingletons</literal>()
      method will completely ignore object definitions which are defined as
      abstract.</para>

      <note>
        <para>ApplicationContexts will by default pre-instantiate all
        singletons. Therefore it is important (at least for singleton objects)
        that if you have a (parent) object definition which you intend to use
        only as a template, and this definition specifies a class, you must
        make sure to set the 'abstract' attribute to 'true', otherwise the
        application context will actually (attempt to) pre-instantiate the
        abstract object.</para>
      </note>

      <para>Spring Actionscript offers a second way of defining a template
      which is almost identical to the above way. There is a specific element
      called <emphasis role="bold"><literal
      xlink:href="dtd://anchor_templateType">
      &lt;template/&gt;</literal></emphasis> that offers the same kind of
      functionality but also has a way of adding parameters to the template's
      definition. Let's take a look at the following <abbrev>XML</abbrev>
      metadata:</para>

      <programlisting>&lt;template id="remoteObject"&gt;
  &lt;object class="mx.rpc.remoting.mxml.RemoteObject"&gt;
   &lt;property name="destination" value="ColdFusion"/&gt;
   &lt;property name="endpoint" value="/flex2gateway/"/&gt;
   &lt;property name="concurrency" value="multiple"/&gt;
   &lt;property name="makeObjectsBindable" value="${makeBindable}"/&gt;
   &lt;property name="showBusyCursor" value="${showCursor}"/&gt;
   &lt;property name="source" value="com.path.to.remoteobjects.${serviceClass}"/&gt;
   &lt;property name="channelSet"&gt;
    &lt;ref&gt;channelset&lt;/ref&gt;
   &lt;/property&gt;
 &lt;/object&gt;
&lt;/template&gt;</programlisting>

      <para>This shows the definition of a RemoteObject template which can be
      re-used for creating different instances of a RemoteObject with
      different parameters. In the <abbrev>XML</abbrev> metadata you can see a
      number of placeholders recognizable by the fact that they are enclosed
      by braces and prefixed with a dollar-sign like this: ${placeholder}.
      These placeholders will be replaced by the values of the parameters that
      are sent to the template when instantiating an object.</para>

      <para>Here is an example of an object definition that makes use of the
      template described above:</para>

      <programlisting>&lt;object id="concreteService" template="remoteObject"&gt;
  &lt;param name="makeBindable" value="false"/&gt;
  &lt;param name="showCursor" value="true"/&gt;
  &lt;param name="serviceClass" value="gatewayname"/&gt;
&lt;/object&gt;</programlisting>

      <note>
        <para>The class that takes care of this functionality is the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.preprocessors.TemplatePreprocessor">TemplatePreprocessor</literal>,
        this class is automatically created by the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.parser.support.XMLObjectDefinitionsParser">XMLObjectDefinitionsParser</literal>
        in its <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.parser.support.XMLObjectDefinitionsParser#preProcessXML()">preProcessXML()</literal>
        method.</para>
      </note>

      <section xml:id="handling_object_inheritance_using_interfaces">
        <title>Handling object inheritance using interfaces</title>

        <para>Another way of defining object configurations is by using the
        interfaces they might implement. Imagine several classes implementing
        the same interface, if only <emphasis>one</emphasis> interface is
        implemented then using an object definition with an '<emphasis
        role="bold">abstract="true"</emphasis>' attribute and having all
        implementing object definitions refer to this definition with their
        '<emphasis role="bold">parent</emphasis>' attribute would suffice,
        even a template would do.</para>

        <para>However, when multiple interfaces are being implemented is when
        you hit the limitations of these configuration options. In this case
        the <literal
        xlink:href="dtd://anchor_interfaceType">&lt;interface/&gt;</literal>
        element might be able to help you out and in this section we will
        explain how.</para>

        <para>Let's make up two simple interfaces for this example:</para>

        <programlisting>public interface ISimpleInterface {
 function get myStringProperty():String;
 function set myStringProperty(value:String):void;
}
</programlisting>

        <programlisting>public interface ISimpleInitializingInterface {
 function initialize():void;
}
</programlisting>

        <para>These interfaces can be configured in the XML configuration like
        this:</para>

        <programlisting>&lt;interface class="com.mycompany.interfaces.ISimpleInterface"&gt;
 &lt;property name="myStringProperty" value="This is my test value!"/&gt;
&lt;/interface&gt;

&lt;interface class="com.mycompany.interfaces.ISimpleInitializingInterface" init-method="initialize"/&gt;</programlisting>

        <para>Now, imagine creating a class that implements the aforementioned
        ISimpleInterface:</para>

        <programlisting>public class MySimpleClass implements ISimpleInterface {
  <lineannotation>//implementation omitted</lineannotation>
}
</programlisting>

        <para>To configure this object in your <abbrev>XML</abbrev> markup all
        you need to do is declare the object:</para>

        <programlisting>&lt;object id="mySimpleInstance" class="com.mycompany.classes.MySimpleClass"/&gt;</programlisting>

        <para>Afterwards Spring Actionscript will take care of combining the
        configurations for the implemented interfaces with your object
        definition.</para>

        <para>This works for multiple interfaces as well, so another class
        that would implement both interfaces. Say, something like this:</para>

        <programlisting>public class MySimpleInitializingClass implements ISimpleInterface, ISimpleInitializingInterface {
 //implementation omitted
}
</programlisting>

        <para>To receive a fully configured instance of this object, all you
        need to do again is simply declare the object like this:</para>

        <programlisting>&lt;object id="mySimpleInitialzingInstance" class="com.mycompany.classes.MySimpleInitializingClass"/&gt;</programlisting>

        <para>And in this case Spring Actionscript will have combined the
        configurations for the ISimpleInterface and
        ISimpleInitializingInterface and added it to the
        mySimpleInitialzingInstance configuration.</para>

        <note>
          <para>The class that takes care of this functionality is the
          <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.preprocessors.InterfacePreprocessor">InterfacePreprocessor</literal>,
          this class is automatically created by the <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.parser.support.XMLObjectDefinitionsParser">XMLObjectDefinitionsParser</literal>
          in its <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.xml.parser.support.XMLObjectDefinitionsParser#preProcessXML()">preProcessXML()</literal>
          method.</para>
        </note>
      </section>
    </section>

    <section xml:id="object_scopes">
      <title>Object scopes</title>

      <para>When you create an object definition what you are actually
      creating is a recipe for creating actual instances of the class defined
      by that object definition. The idea that an object definition is a
      recipe is important, because it means that, just like a class, you can
      potentially have many object instances created from a single
      recipe.</para>

      <para>You can control not only the various dependencies and
      configuration values that are to be plugged into an object that is
      created from a particular object definition, but also the scope of the
      objects created from a particular object definition. This approach is
      very powerful and gives you the flexibility to choose the scope of the
      objects you create through configuration instead of having to 'bake in'
      the scope of an object at the Actionscript class level. Objects can be
      defined to be deployed in one of a number of scopes: out of the box,
      Spring Actionscript supports exactly two scopes.</para>

      <para>The scopes supported out of the box are listed below:<table
          border="1">
          <caption>Object scopes</caption>

          <tr>
            <th>Scope</th>

            <th>Description</th>
          </tr>

          <tr>
            <td>singleton</td>

            <td>Scopes a single object definition to a single object instance
            per Spring Actionscript <abbrev>IoC</abbrev> container.</td>
          </tr>

          <tr>
            <td>prototype</td>

            <td>Scopes a single object definition to any number of object
            instances.</td>
          </tr>
        </table></para>

      <section xml:id="the_singleton_scope">
        <title>The singleton scope</title>

        <para>When an object is a singleton, only one shared instance of the
        object will be managed, and all requests for objects with an id
        matching that object definition will result in that one specific
        object instance being returned by the Spring Actionscript
        container.</para>

        <para>To put it another way, when you define an object definition and
        it is scoped as a singleton, then the Spring Actionscript
        <abbrev>IoC</abbrev> container will create exactly one instance of the
        object defined by that object definition. This single instance will be
        stored in a cache of such singleton objects, and all subsequent
        requests and references for that named object will result in the
        cached object being returned.</para>

        <para>Please be aware that Spring Actionscript's concept of a
        singleton object is quite different from the Singleton pattern as
        defined in the seminal Gang of Four (GoF) patterns book. The GoF
        Singleton hard codes the scope of an object such that one and only one
        instance of a particular class will ever be created. The scope of the
        Spring Actionscript singleton is best described as per container and
        per object. This means that if you define one object for a particular
        class in a single Spring Actionscript container, then the Spring
        Actionscript container will create one and only one instance of the
        class defined by that object definition. The singleton scope is the
        default scope in Spring Actionscript. To define an object as a
        singleton in XML, you would write configuration like so:</para>

        <programlisting>&lt;object id="accountService" class="com.foo.DefaultAccountService"/&gt;

<lineannotation>&lt;!-- the following is equivalent, though redundant (singleton scope is the default) --&gt;</lineannotation>
&lt;object id="accountService" class="com.foo.DefaultAccountService" scope="singleton"/&gt;

<lineannotation>&lt;!-- the following is equivalent and preserved for backward compatibility --&gt;</lineannotation>
&lt;object id="accountService" class="com.foo.DefaultAccountService" singleton="true"/&gt;</programlisting>
      </section>

      <section xml:id="the_prototype_scope">
        <title>The prototype scope</title>

        <para>The non-singleton, prototype scope of object deployment results
        in the creation of a new object instance every time a request for that
        specific object is made (that is, it is injected into another object
        or it is requested via a programmatic <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactory#getObject()">getObject()</literal>
        method call on the container). As a rule of thumb, you should use the
        prototype scope for all objecs that are stateful, while the singleton
        scope should be used for stateless objects.</para>

        <para>To define an object as a prototype in XML, you would write
        configuration like so:</para>

        <programlisting><lineannotation>&lt;!-- recommended markup --&gt;</lineannotation>
&lt;object id="accountService" class="com.foo.DefaultAccountService" scope="prototype"/&gt;

<lineannotation>&lt;!-- the following is equivalent and preserved for backward compatibility --&gt;</lineannotation>
&lt;object id="accountService" class="com.foo.DefaultAccountService" singleton="false"/&gt;</programlisting>
      </section>

      <section xml:id="singleton_objects_with_prototype_dependencies">
        <title>Singleton objecs with prototype-object dependencies</title>

        <para>When using singleton-scoped objects that have dependencies on
        objects that are scoped as prototypes, please be aware that
        <emphasis>dependencies are resolved at instantiation time</emphasis>.
        This means that if you dependency inject a prototype-scoped object
        into a singleton-scoped object, a brand new prototype object will be
        instantiated and then dependency injected into the singleton object...
        but that is all. That exact same prototype instance will be the sole
        instance that is ever supplied to the singleton-scoped object, which
        is fine if that is what you want.</para>

        <para>However, sometimes what you actually want is for the
        singleton-scoped object to be able to acquire a brand new instance of
        the prototype-scoped bean again and again and again at runtime. In
        that case it is no use just dependency injecting a prototype-scoped
        object into your singleton object, because as explained above, that
        only happens once when the Spring Actionscript container is
        instantiating the singleton object and resolving and injecting its
        dependencies.</para>
      </section>
    </section>

    <section xml:id="customizing_the_nature_of_an_object2">
      <title>Customizing the nature of an object</title>

      <section xml:id="lifecycle_callbacks">
        <title>Lifecycle callbacks</title>

        <para>The Spring Actionscript Framework provides a callback interface
        to change the behavior of your object in the container; this is the
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IInitializingObject">IInitializingObject</literal>
        interface. Implementing this interface will result in the container
        calling the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IInitializingObject#afterPropertiesSet()">afterPropertiesSet()</literal>
        method immediately after the object has been created and configured,
        but <emphasis>before</emphasis> its initialization method is called
        (defined by the init-method attribute).</para>

        <para>Internally, the Spring Actionscript Framework uses <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">IObjectPostProcessor</literal>
        implementations to process any callback interfaces it can find and
        call the appropriate methods. If you need custom features or other
        lifecycle behavior Spring Actionscript doesn't offer out-of-the-box,
        you can implement an <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">IObjectPostProcessor</literal>
        yourself. More information about this can be found in the section
        entitled <literal xlink:href="#container_extension_points">"Container
        extension points"</literal>.</para>
      </section>

      <section xml:id="initialization_callbacks2">
        <title>Initialization callbacks</title>

        <para>Implementing the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IInitializingObject">org.springextensions.actionscript.ioc.factory.IInitializingObject</literal>
        interface allows an object to perform initialization work after all
        necessary properties on the object have been set by the container. The
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IInitializingObject">IInitializingObject</literal>
        interface specifies exactly one method:</para>

        <programlisting>function afterPropertiesSet():void;</programlisting>

        <para>Generally, the use of the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IInitializingObject">IInitializingObject</literal>
        interface can be avoided and is actually discouraged since it
        unnecessarily couples the code to Spring Actionscript. As an
        alternative, objects definitions provide support for a generic
        initialization method to be specified. In the case of XML-based
        configuration metadata, this is done using the 'init-method'
        attribute. For example, the following definition:</para>

        <programlisting>&lt;object id="exampleInitObject" class="examples.ExampleObject" init-method="init"/&gt;</programlisting>

        <programlisting>public class ExampleObject {
    
    public function init():void {
        <lineannotation>// do some initialization work</lineannotation>
    }
}</programlisting>

        <para>...is exactly the same as...</para>

        <programlisting>&lt;object id="exampleInitObject" class="examples.AnotherExampleObject"/&gt;</programlisting>

        <programlisting>public class AnotherExampleObject implements IInitializingObject {
    
    public function afterPropertiesSet():void {
        <lineannotation>// do some initialization work</lineannotation>
    }
}</programlisting>

        <para>... but does not couple the code to Spring Actionscript.</para>
      </section>
    </section>

    <section xml:id="container_extension_points">
      <title>Container extension points</title>

      <para>The <abbrev>IoC</abbrev> component of the Spring Actionscript
      Framework has been designed for extension. There is typically no need
      for an application developer to subclass the ApplicationContext class.
      The Spring Actionscript <abbrev>IoC</abbrev> container can be infinitely
      extended by plugging in implementations of special integration
      interfaces.</para>

      <para>Spring Actionscript can be extended through the <literal
      xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">IObjectPostProcessor</literal>,
      <literal
      xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectFactoryPostProcessor">IObjectFactoryPostProcessor</literal>
      and <literal
      xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>
      interfaces.</para>

      <para>First we look at some existing examples of these interfaces and
      after that there is a small tutorial on how to build your own
      implementation.</para>

      <para>The following are a few implementations of these interfaces that
      Spring Actionscript supports 'out of the box' to help you out in daily
      development life.</para>

      <section xml:id="flex_application_settings">
        <title>Flex application settings</title>

        <para>Specifically for the <literal
        xlink:href="asdoc://org.springextensions.actionscript.context.support.FlexXMLApplicationContext">FlexXMLApplicationContext</literal>
        there is the ability to refer to the properties of the Application
        class directly from the container's metadata. These properties can be
        used as regular property placeholders in an application context or a
        properties file. e.g. ${application.url}.</para>

        <para>The following properties are supported:</para>

        <itemizedlist>
          <listitem>
            <para>application.frameRate</para>
          </listitem>

          <listitem>
            <para>application.historyManagementEnabled</para>
          </listitem>

          <listitem>
            <para>application.pageTitle</para>
          </listitem>

          <listitem>
            <para>application.resetHistory</para>
          </listitem>

          <listitem>
            <para>application.scriptRecursionLimit</para>
          </listitem>

          <listitem>
            <para>application.scriptTimeLimit</para>
          </listitem>

          <listitem>
            <para>application.url</para>
          </listitem>

          <listitem>
            <para>application.url.protocol</para>
          </listitem>

          <listitem>
            <para>application.url.host</para>
          </listitem>

          <listitem>
            <para>application.url.port</para>
          </listitem>

          <listitem>
            <para>application.usePreloader</para>
          </listitem>

          <listitem>
            <para>application.viewSourceURL</para>
          </listitem>

          <listitem>
            <para>application.parameters (when they exist)</para>
          </listitem>
        </itemizedlist>

        <para>Individual flashvars are automatically added to the application
        settings, so if a flashvar called <emphasis>myFlashVar</emphasis> is
        passed to the application it will be available as
        <emphasis>application.myFlashVar</emphasis> in the context.</para>
      </section>

      <section xml:id="logging_target_factory">
        <title>Logging target factory</title>

        <para>The logging target this factory creates will automatically be
        added to the log manager class.</para>

        <programlisting>&lt;object id="traceTarget" class="org.springextensions.actionscript.ioc.factory.config.LoggingTargetFactoryObject"&gt;
 &lt;property name="loggingTargetClass" value="mx.logging.targets.TraceTarget"/&gt;
 &lt;property name="includeCategory" value="true"/&gt;
 &lt;property name="includeDate" value="true"/&gt;
 &lt;property name="includeLevel" value="true"/&gt;
 &lt;property name="includeTime" value="true"/&gt;
 &lt;property name="level" value="2"/&gt;
 &lt;property name="filters"&gt;
 &lt;array&gt;
  &lt;value&gt;com.domain.model.*&lt;/value&gt;
  &lt;value&gt;com.domain.view.*&lt;/value&gt;
 &lt;/array&gt;
 &lt;/property&gt;
&lt;/object&gt;</programlisting>
      </section>

      <section xml:id="enforcing_required_property_injections">
        <title>Enforcing required property injections</title>

        <para>This is an <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">IObjectPostProcessor</literal>
        implementation that enforces required properties to be injected. A
        property is marked as required by adding <emphasis
        role="bold">[Required]</emphasis> metadata to the property
        definition:</para>

        <programlisting>[Required]
public var myProperty:Type;</programlisting>

        <para>If the property has been defined as required but a suitable
        injection candidate cannot be found by the container it will throw an
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.errors.IllegalArgumentError">IllegalArgumentError</literal>
        exception.</para>

        <para>In order to use it in your application, include it as an object
        in your application context:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.ioc.factory.config.RequiredMetadataObjectPostProcessor"/&gt;</programlisting>
      </section>

      <section xml:id="injecting_the_object_factory">
        <title>Injecting the object factory</title>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.ObjectFactoryAwarePostProcessor">ObjectFactoryAwarePostProcessor</literal>
        will check if the object that has just been created by the container
        implements the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IObjectFactoryAware">IObjectContainerAware</literal>
        interface. If this is found to be true it will inject the container as
        a property on the specified object.</para>

        <para>In order to use it in your application, include it as an object
        in your application context:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.ioc.factory.config.ObjectFactoryAwarePostProcessor"/&gt;</programlisting>
      </section>

      <section xml:id="injecting_fields_from_other_objects">
        <title>Injecting fields from other objects</title>

        <para>Sometimes it is necessary to use the value of another object's
        field to be injected into a new object. Spring Actionscript offers the
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.FieldRetrievingFactoryObject">FieldRetrievingFactoryObject</literal>
        the this specific task. Configuration for this object is fairly
        straightforward, here is an example of its usage:</para>

        <programlisting>&lt;object id="trafficEventManager" class="com.myclasses.TrafficEventManager"&gt;
 &lt;constructor-arg&gt;
  &lt;object class="org.springextensions.actionscript.ioc.factory.config.FieldRetrievingFactoryObject"&gt;
   &lt;property name="targetObject" ref="modelLocator" /&gt;
   &lt;property name="targetField" value="trafficEventTypes" /&gt;
  &lt;/object&gt;
 &lt;/constructor-arg&gt;
&lt;/object&gt;</programlisting>

        <para>The TrafficEventManager instance requires an ArrayCollection of
        event types to be passed to its constructor. In this example we assume
        this list of event types is defined in the modelLocator instance by
        its trafficEventTypes property. With the above example this value is
        now injected into the TrafficEventManager's constructor.</para>

        <note>
          <para>The <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.FieldRetrievingFactoryObject">FieldRetrievingFactoryObject</literal>
          supports both instance and static properties.</para>
        </note>

        <para>Here's how the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.FieldRetrievingFactoryObject">FieldRetrievingFactoryObject</literal>
        can be used to retrieve a static field:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.ioc.factory.config.FieldRetrievingFactoryObject"&gt;
  &lt;property name="staticField" value="CURRENT_VERSION"/&gt;
  &lt;property name="targetClass" value="mx.core.FlexVersion/&gt;
&lt;/object&gt;</programlisting>
      </section>

      <section xml:id="injecting_method_invocation_results_from_other_objects">
        <title>Injecting method invocation results from other objects</title>

        <para>Not just properties can be retrieved from other objects, also
        the result of method invocations on these objects can be used to
        inject into other objects. The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.MethodInvokingFactoryObject">MethodInvokingFactoryObject</literal>
        deals with these kinds of situations. Here is an example:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.ioc.factory.config.MethodInvokingFactoryObject" id="<emphasis
            role="bold">resourceManager</emphasis>"&gt;
      &lt;property name="targetClass" value="mx.resources.ResourceManager"/&gt;
      &lt;property name="targetMethod" value="getInstance"/&gt;
&lt;/object&gt;</programlisting>

        <para>This will call the static getInstance() method on the
        mx.resources.ResourceManager class. It is also possible to call a
        method on an instance, here's how:</para>

        <programlisting>&lt;object class="org.springextensions.actionscript.ioc.factory.config.MethodInvokingFactoryObject" id="resourceValue"&gt;
      &lt;property name="targetObject" value="<emphasis role="bold">resourceManager</emphasis>"/&gt;
      &lt;property name="targetMethod" value="getString"/&gt;
      &lt;property name="arguments"&gt;
        &lt;array&gt;
          &lt;value&gt;bundleName&lt;/value&gt;
          &lt;value&gt;resourceName&lt;/value&gt;
        &lt;/array&gt;
      &lt;/property&gt;
&lt;/object&gt;</programlisting>

        <para>This will retrieve the previously instantiated resourceManager
        from the first example and invokes the getString() method on it using
        the specified array of arguments.</para>
      </section>

      <section xml:id="customizing_objects_using_objectpostprocessors">
        <title>Customizing objects using ObjectPostProcessors</title>

        <para>The first extension point that we will look at is the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">IObjectPostProcessor</literal>
        interface. This interface defines a number of callback methods that
        you as an application developer can implement in order to provide your
        own (or override the containers default) instantiation logic,
        dependency-resolution logic, and so forth. If you want to do some
        custom logic after the Spring Actionscript container has finished
        instantiating, configuring and otherwise initializing an object, you
        can plug in one or more <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">IObjectPostProcessor</literal>
        implementations.</para>

        <note>
          <para>IObjectPostProcessors operate on object instances; that is to
          say, the Spring Actionscript <abbrev>IoC</abbrev> container will
          have instantiated an object instance for you, and then
          IObjectPostProcessors get a chance to do their stuff. If you want to
          change the actual object definition (that is the recipe that defines
          the object), then you rather need to use a
          IObjectFactoryPostProcessor (described below in the section entitled
          <literal
          xlink:href="#customizing_with_iobjectfactorypostprocessor">"Customizing
          configuration metadata with the IObjectFactoryPostProcessor
          interface"</literal>.</para>
        </note>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor</literal>
        interface consists of exactly two callback methods. When such a class
        is registered as a post-processor with the container, for each object
        instance that is created by the container, the post-processor will get
        a callback from the container both before any container initialization
        methods (such as afterPropertiesSet and any declared init method) are
        called, and also afterwards. The post-processor is free to do what it
        wishes with the object instance, including ignoring the callback
        completely. An object post-processor will typically check for callback
        interfaces, or do something such as wrap an object with a
        proxy.</para>

        <para>An ApplicationContext will automatically detect any objects
        which are defined in the configuration metadata which is supplied to
        it that implement the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">IObjectPostProcessor</literal>
        interface, and register them as post-processors, to be then called
        appropriately by the container on object creation. Nothing else needs
        to be done other than deploying the post-processors in a similar
        fashion to any other object.</para>

        <note>
          <para>You can force the object factory to ignore its list of
          <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">IObjectPostProcessors</literal>
          for a given <literal
          xlink:href="asdoc://org.springextensions.actionscript.ioc.ObjectDefinition">ObjectDefinition</literal>
          by setting its <emphasis>skip-postprocessors</emphasis> attribute to
          <emphasis role="bold">true</emphasis>. This will yield a small
          performance boost.</para>
        </note>
      </section>

      <section xml:id="creating_a_postprocessor">
        <title>Creating a postprocessor</title>

        <para>Let's see how we can build our own processor. Suppose we have an
        IProductManager interface that looks like this:</para>

        <programlisting>public interface IProductManager {

 function get items():ArrayCollection;
 function set items(value:ArrayCollection):void;
}</programlisting>

        <para>At runtime the actual items will be loaded by a server call and
        stored in the application model. Since we won't know
        <emphasis>exactly</emphasis> when the items will be loaded we can't
        use the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.FieldRetrievingFactoryObject">FieldRetrievingFactoryObject</literal>
        to simply assign the model's items to the items property of the
        IProductManager instance. What we'd like to do is actually
        <emphasis>bind</emphasis> the productmanager's items to the model
        items.</para>

        <para>Let's see if we can build something that performs this task. We
        will implement the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">IObjectPostProcessor</literal>
        interfaces like this:</para>

        <programlisting>public class PropertyBindingPostProcessor implements IObjectPostProcessor {

 public function PropertyBindingPostProcessor() {
  super();
 }
 
 private var _host:Object;
 public set host(value:Object):void {
  _host = host;
 }
 private var _chain:Object;
 public set chain(value:Object):void {
  _chain = value;
 }

 public function postProcessBeforeInitialization(object:*, objectName:String):* {
  Assert.notNull(_host,"host property cannot be null");
  Assert.notNull(_chain,"chain property cannot be null");
  if (object is IProductManager)
  {
   BindingUtils.bindProperty(object,'items',host,chain);
  }
 }
 
 public function postProcessAfterInitialization(object:*, objectName:String):* {
  return null;
 }

}</programlisting>

        <para>Now all we need to do is add this bit of configuration and the
        post processor is ready to do its work:</para>

        <programlisting>&lt;object id="propertyBindingPostProcessor" class="com.myclasses.postprocessors.PropertyBindingPostProcessor"&gt;
 &lt;property name="host" ref="modelInstance"/&gt;
 &lt;property name="chain" value="items"/&gt;
&lt;/object&gt;
</programlisting>

        <para>That's it basically it! Now its certainly possible to come up
        with a much more generic solution than this, but it does show its
        fairly easy to create your own post processors for specific
        tasks.</para>
      </section>

      <section xml:id="customizing_instantiation_logic_using_the_ifactoryobject_interface">
        <title>Customizing instantiation logic using the IFactoryObject
        interface</title>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">org.springextensions.actionscript.ioc.factory.IFactoryObject</literal>
        interface is to be implemented by objects that <emphasis>are
        themselves factories</emphasis>.</para>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>
        interface is a point of pluggability into the Spring Actionscript
        <abbrev>IoC</abbrev> containers instantiation logic. If you have some
        complex initialization code that is better expressed in Actionscript
        as opposed to a (potentially) verbose amount of XML, you can create
        your own <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>,
        write the complex initialization inside that class, and then plug your
        custom <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>
        into the container.</para>

        <para>Now when you request an instance of such an
        <literal>IFactoryObject</literal> from the container, it doesn't
        actually return an <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject"
        xlink:role="">IFactoryObject</literal> instance, instead, it calls the
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject#getObject()">getObject()</literal>
        method on the object and returns the result of this method.</para>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>
        interface provides three methods:</para>

        <itemizedlist>
          <listitem>
            <para>getObject():*; has to return an instance of the object this
            factory creates. The instance can possibly be shared (depending on
            whether this factory returns singletons or prototypes).</para>
          </listitem>

          <listitem>
            <para>isSingleton():Boolean; has to return true if this
            IFactoryObject returns singletons, false otherwise</para>
          </listitem>

          <listitem>
            <para>getObjectType():Class; has to return either the object type
            returned by the getObject() method or null if the type isn't known
            in advance</para>
          </listitem>
        </itemizedlist>

        <para>Let's say we need to instantiate an object of class
        IncrediblyComplicatedObject. The initialization of this object
        involves some kind of logic that is beyond the scope of Spring
        Actionscript and way too complicated to be expressed in
        <abbrev>XML</abbrev>. We <emphasis>are</emphasis> of course able to
        write our own code to perform this. We can now build an <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>
        that implements this task:</para>

        <programlisting>public class IncrediblyComplicatedObjectFactory implements IFactoryObject {

 public function getObject():* {
  var instance:IncrediblyComplicatedObject = new IncrediblyComplicatedObject();
  <lineannotation>//creation logic ommitted</lineannotation>
  return instance;
 }

 public function getObjectType():Class {
  return IncrediblyComplicatedObject;
 }

 public function get isSingleton():Boolean {
  return false;
 }

}</programlisting>

        <para>The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject#isSingleton()"
        xml:base="">isSingleton()</literal> method returns false, this means
        that every time this <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>
        is requested from the container, it creates a new instance of
        IncrediblyComplicatedObject. When set to true it will create an
        instance once, and return this on every subsequent call. (At least, if
        the interface is properly implemented :) ).</para>

        <para>In order to use an <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>
        in your application, include it as an object in your application
        context:</para>

        <programlisting>&lt;object class="com.myclasses.factories.IncrediblyComplicatedObjectFactory" id="incrediblyComplicatedObject"/&gt;</programlisting>

        <para>After that, requesting an instance of
        IncrediblyComplicatedObject is the same as requesting any other
        ordinary object from the container:</para>

        <programlisting>var complicated:IncrediblyComplicatedObject = applicationContext.getObject("incrediblyComplicatedObject") as IncrediblyComplicatedObject;</programlisting>

        <para>Finally, there is sometimes a need to ask a container for an
        actual <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>
        instance itself, not the object it produces. This may be achieved by
        prepending the object id with '&amp;' (sans quotes) when calling the
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.support.AbstractObjectFactory#getObject()">getObject</literal>
        method of the ObjectFactory (including ApplicationContext). So for a
        given <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>
        with an id of myObject, invoking getObject("myObject") on the
        container will return the product of the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>,
        but invoking getObject("&amp;myObject") will return the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IFactoryObject">IFactoryObject</literal>
        instance itself.</para>
      </section>

      <section xml:id="customizing_with_iobjectfactorypostprocessor">
        <title>Customizing configuration metadata with the
        IObjectFactoryPostProcessor interface</title>

        <para>The next extension point that we will look at is the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectFactoryPostProcessor">org.springextensions.actionscript.ioc.factory.config.IObjectFactoryPostProcessor</literal>.
        The semantics of this interface are similar to the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectPostProcessor">IObjectPostProcessor</literal>,
        with one major difference: <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectFactoryPostProcessor">IObjectFactoryPostProcessors</literal>
        operate on the object configuration metadata; that is, the Spring
        Actionscript <abbrev>IoC</abbrev> container will allow <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectFactoryPostProcessor">IObjectFactoryPostProcessors</literal>
        to read the configuration metadata and potentially change it before
        the container has actually instantiated any other objects.</para>

        <para>The interface is fairly simple as you can see:</para>

        <programlisting>public interface IObjectFactoryPostProcessor {

 function postProcessObjectFactory(objectFactory:IConfigurableListableObjectFactory):void;
}</programlisting>

        <para>In order to use an <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectFactoryPostProcessor">IObjectFactoryPostProcessor</literal>
        in your application, include the implementation as an object in your
        application context:</para>

        <programlisting>&lt;object class="com.myclasses.postprocessors.MyObjectFactoryPostProcessor" id="objectFactoryPostProcessor"/&gt;</programlisting>

        <para>Now after the application context has finished loading its
        configuration file, and <emphasis>before</emphasis> it starts
        instantiating any objects every <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectFactoryPostProcessor">IObjectFactoryPostProcessor</literal>
        that was found in the configuration will be invoked by calling its
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectFactoryPostProcessor#postProcessObjectFactory()">postProcessObjectFactory()</literal>
        method and passing the current <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IConfigurableListableObjectFactory">IConfigurableListableObjectFactory</literal>
        instance as the argument. The <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IObjectFactoryPostProcessor">IObjectFactoryPostProcessor</literal>
        can then use the <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IConfigurableObjectFactory">IConfigurableObjectFactory</literal>,
        <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.IListableObjectFactory">IListableObjectFactory</literal>
        and <literal
        xlink:href="asdoc://org.springextensions.actionscript.ioc.factory.config.IConfigurableListableObjectFactory">IConfigurableListableObjectFactory</literal>
        interfaces to perform whatever postprocessing logic is
        necessary.</para>

        <note>
          <para>Just as in the case of IObjectPostProcessors, you typically
          don't want to have IObjectFactoryPostProcessors marked as being
          lazily-initialized. If they are marked as such, then the Spring
          Actionscript container will never instantiate them, and thus they
          won't get a chance to apply their custom logic.</para>
        </note>
      </section>
    </section>

    <section xml:id="controlling_collection_order">
      <title>Controlling collection order</title>

      <para>Several collections (ObjectFactoryPostProcessors,
      ObjectPostProcessors, ClassScanners and MetadataProcessors) available in
      the application context can be sorted into a prefered order using the
      <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.IOrdered">IOrdered</literal>
      interface. Let's have a look at it:</para>

      <programlisting>public interface IOrdered {

 function get order():int;

 function set order(value:int):void;

}
</programlisting>

      <para>The actual order can be interpreted as prioritization, with the
      first object (with the lowest order value) having the highest priority.
      When collections are sorted that contain objects that do not implement
      the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.IOrdered">IOrdered</literal>
      interface first the <literal
      xlink:href="asdoc://org.springextensions.actionscript.core.IOrdered">IOrdered</literal>
      implementations will be sorted with the lowest order value first, after
      that the remaining objects will be concatenated unordered. For sorting
      such a collection the static method <literal
      xlink:href="asdoc://org.springextensions.actionscript.utils.OrderedUtils#sortOrderedArray()">OrderedUtils.sortOrderedArray()</literal>
      may be used.</para>
    </section>
  </section>
</chapter>
